<!DOCTYPE html>
<html lang="en">
<meta http-equiv="content-type" content="text/html;charset=UTF-8"/>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="author" content="RaviKalyan">
    <title>Java Core</title>
    <link rel="shortcut icon" type="image/x-icon" href="../../scripts/images/tab_logo.png"/>
    <link rel="stylesheet" href="../../scripts/css/site.css">
    <link rel='stylesheet' id='blogus-google-fonts-css'
          href='//fonts.googleapis.com/css?family=ABeeZee%7CAbel%7CAbril+Fatface%7CAclonica%7CAcme%7CActor%7CAdamina%7CAdvent+Pro%7CAguafina+Script%7CAkronim%7CAladin%7CAldrich%7CAlef%7CAlegreya%7CAlegreya+SC%7CAlegreya+Sans%7CAlegreya+Sans+SC%7CAlex+Brush%7CAlfa+Slab+One%7CAlice%7CAlike%7CAlike+Angular%7CAllan%7CAllerta%7CAllerta+Stencil%7CAllura%7CAlmendra%7CAlmendra+Display%7CAlmendra+SC%7CAmarante%7CAmaranth%7CAmatic+SC%7CAmatica+SC%7CAmethysta%7CAmiko%7CAmiri%7CAmita%7CAnaheim%7CAndada%7CAndika%7CAngkor%7CAnnie+Use+Your+Telescope%7CAnonymous+Pro%7CAntic%7CAntic+Didone%7CAntic+Slab%7CAnton%7CArapey%7CArbutus%7CArbutus+Slab%7CArchitects+Daughter%7CArchivo+Black%7CArchivo+Narrow%7CAref+Ruqaa%7CArima+Madurai%7CArimo%7CArizonia%7CArmata%7CArtifika%7CArvo%7CArya%7CAsap%7CAsar%7CAsset%7CAssistant%7CAstloch%7CAsul%7CAthiti%7CAtma%7CAtomic+Age%7CAubrey%7CAudiowide%7CAutour+One%7CAverage%7CAverage+Sans%7CAveria+Gruesa+Libre%7CAveria+Libre%7CAveria+Sans+Libre%7CAveria+Serif+Libre%7CBad+Script%7CBaloo%7CBaloo+Bhai%7CBaloo+Da%7CBaloo+Thambi%7CBalthazar%7CBangers%7CBasic%7CBattambang%7CBaumans%7CBayon%7CBelgrano%7CBelleza%7CBenchNine%7CBentham%7CBerkshire+Swash%7CBevan%7CBigelow+Rules%7CBigshot+One%7CBilbo%7CBilbo+Swash+Caps%7CBioRhyme%7CBioRhyme+Expanded%7CBiryani%7CBitter%7CBlack+Ops+One%7CBokor%7CBonbon%7CBoogaloo%7CBowlby+One%7CBowlby+One+SC%7CBrawler%7CBree+Serif%7CBubblegum+Sans%7CBubbler+One%7CBuda%7CBuenard%7CBungee%7CBungee+Hairline%7CBungee+Inline%7CBungee+Outline%7CBungee+Shade%7CButcherman%7CButterfly+Kids%7CCabin%7CCabin+Condensed%7CCabin+Sketch%7CCaesar+Dressing%7CCagliostro%7CCairo%7CCalligraffitti%7CCambay%7CCambo%7CCandal%7CCantarell%7CCantata+One%7CCantora+One%7CCapriola%7CCardo%7CCarme%7CCarrois+Gothic%7CCarrois+Gothic+SC%7CCarter+One%7CCatamaran%7CCaudex%7CCaveat%7CCaveat+Brush%7CCedarville+Cursive%7CCeviche+One%7CChanga%7CChanga+One%7CChango%7CChathura%7CChau+Philomene+One%7CChela+One%7CChelsea+Market%7CChenla%7CCherry+Cream+Soda%7CCherry+Swash%7CChewy%7CChicle%7CChivo%7CChonburi%7CCinzel%7CCinzel+Decorative%7CClicker+Script%7CCoda%7CCoda+Caption%7CCodystar%7CCoiny%7CCombo%7CComfortaa%7CComing+Soon%7CConcert+One%7CCondiment%7CContent%7CContrail+One%7CConvergence%7CCookie%7CCopse%7CCorben%7CCormorant%7CCormorant+Garamond%7CCormorant+Infant%7CCormorant+SC%7CCormorant+Unicase%7CCormorant+Upright%7CCourgette%7CCousine%7CCoustard%7CCovered+By+Your+Grace%7CCrafty+Girls%7CCreepster%7CCrete+Round%7CCrimson+Text%7CCroissant+One%7CCrushed%7CCuprum%7CCutive%7CCutive+Mono%7CDamion%7CDancing+Script%7CDangrek%7CDavid+Libre%7CDawning+of+a+New+Day%7CDays+One%7CDekko%7CDelius%7CDelius+Swash+Caps%7CDelius+Unicase%7CDella+Respira%7CDenk+One%7CDevonshire%7CDhurjati%7CDidact+Gothic%7CDiplomata%7CDiplomata+SC%7CDomine%7CDonegal+One%7CDoppio+One%7CDorsa%7CDosis%7CDr+Sugiyama%7CDroid+Sans%7CDroid+Sans+Mono%7CDroid+Serif%7CDuru+Sans%7CDynalight%7CEB+Garamond%7CEagle+Lake%7CEater%7CEconomica%7CEczar%7CEk+Mukta%7CEl+Messiri%7CElectrolize%7CElsie%7CElsie+Swash+Caps%7CEmblema+One%7CEmilys+Candy%7CEngagement%7CEnglebert%7CEnriqueta%7CErica+One%7CEsteban%7CEuphoria+Script%7CEwert%7CExo%7CExo+2%7CExpletus+Sans%7CFanwood+Text%7CFarsan%7CFascinate%7CFascinate+Inline%7CFaster+One%7CFasthand%7CFauna+One%7CFederant%7CFedero%7CFelipa%7CFenix%7CFinger+Paint%7CFira+Mono%7CFira+Sans%7CFjalla+One%7CFjord+One%7CFlamenco%7CFlavors%7CFondamento%7CFontdiner+Swanky%7CForum%7CFrancois+One%7CFrank+Ruhl+Libre%7CFreckle+Face%7CFredericka+the+Great%7CFredoka+One%7CFreehand%7CFresca%7CFrijole%7CFruktur%7CFugaz+One%7CGFS+Didot%7CGFS+Neohellenic%7CGabriela%7CGafata%7CGalada%7CGaldeano%7CGalindo%7CGentium+Basic%7CGentium+Book+Basic%7CGeo%7CGeostar%7CGeostar+Fill%7CGermania+One%7CGidugu%7CGilda+Display%7CGive+You+Glory%7CGlass+Antiqua%7CGlegoo%7CGloria+Hallelujah%7CGoblin+One%7CGochi+Hand%7CGorditas%7CGoudy+Bookletter+1911%7CGraduate%7CGrand+Hotel%7CGravitas+One%7CGreat+Vibes%7CGriffy%7CGruppo%7CGudea%7CGurajada%7CHabibi%7CHalant%7CHammersmith+One%7CHanalei%7CHanalei+Fill%7CHandlee%7CHanuman%7CHappy+Monkey%7CHarmattan%7CHeadland+One%7CHeebo%7CHenny+Penny%7CHerr+Von+Muellerhoff%7CHind%7CHind+Guntur%7CHind+Madurai%7CHind+Siliguri%7CHind+Vadodara%7CHoltwood+One+SC%7CHomemade+Apple%7CHomenaje%7CIM+Fell+DW+Pica%7CIM+Fell+DW+Pica+SC%7CIM+Fell+Double+Pica%7CIM+Fell+Double+Pica+SC%7CIM+Fell+English%7CIM+Fell+English+SC%7CIM+Fell+French+Canon%7CIM+Fell+French+Canon+SC%7CIM+Fell+Great+Primer%7CIM+Fell+Great+Primer+SC%7CIceberg%7CIceland%7CImprima%7CInconsolata%7CInder%7CIndie+Flower%7CInika%7CInknut+Antiqua%7CIrish+Grover%7CIstok+Web%7CItaliana%7CItalianno%7CItim%7CJacques+Francois%7CJacques+Francois+Shadow%7CJaldi%7CJim+Nightshade%7CJockey+One%7CJolly+Lodger%7CJomhuria%7CJosefin+Sans%7CJosefin+Slab%7CJoti+One%7CJudson%7CJulee%7CJulius+Sans+One%7CJunge%7CJura%7CJust+Another+Hand%7CJust+Me+Again+Down+Here%7CKadwa%7CKalam%7CKameron%7CKanit%7CKantumruy%7CKarla%7CKarma%7CKatibeh%7CKaushan+Script%7CKavivanar%7CKavoon%7CKdam+Thmor%7CKeania+One%7CKelly+Slab%7CKenia%7CKhand%7CKhmer%7CKhula%7CKite+One%7CKnewave%7CKotta+One%7CKoulen%7CKranky%7CKreon%7CKristi%7CKrona+One%7CKumar+One%7CKumar+One+Outline%7CKurale%7CLa+Belle+Aurore%7CLaila%7CLakki+Reddy%7CLalezar%7CLancelot%7CLateef%7CLato%7CLeague+Script%7CLeckerli+One%7CLedger%7CLekton%7CLemon%7CLemonada%7CLibre+Baskerville%7CLibre+Franklin%7CLife+Savers%7CLilita+One%7CLily+Script+One%7CLimelight%7CLinden+Hill%7CLobster%7CLobster+Two%7CLondrina+Outline%7CLondrina+Shadow%7CLondrina+Sketch%7CLondrina+Solid%7CLora%7CLove+Ya+Like+A+Sister%7CLoved+by+the+King%7CLovers+Quarrel%7CLuckiest+Guy%7CLusitana%7CLustria%7CMacondo%7CMacondo+Swash+Caps%7CMada%7CMagra%7CMaiden+Orange%7CMaitree%7CMako%7CMallanna%7CMandali%7CMarcellus%7CMarcellus+SC%7CMarck+Script%7CMargarine%7CMarko+One%7CMarmelad%7CMartel%7CMartel+Sans%7CMarvel%7CMate%7CMate+SC%7CMaven+Pro%7CMcLaren%7CMeddon%7CMedievalSharp%7CMedula+One%7CMeera+Inimai%7CMegrim%7CMeie+Script%7CMerienda%7CMerienda+One%7CMerriweather%7CMerriweather+Sans%7CMetal%7CMetal+Mania%7CMetamorphous%7CMetrophobic%7CMichroma%7CMilonga%7CMiltonian%7CMiltonian+Tattoo%7CMiniver%7CMiriam+Libre%7CMirza%7CMiss+Fajardose%7CMitr%7CModak%7CModern+Antiqua%7CMogra%7CMolengo%7CMolle%7CMonda%7CMonofett%7CMonoton%7CMonsieur+La+Doulaise%7CMontaga%7CMontez%7CMontserrat%7CMontserrat+Alternates%7CMontserrat+Subrayada%7CMoul%7CMoulpali%7CMountains+of+Christmas%7CMouse+Memoirs%7CMr+Bedfort%7CMr+Dafoe%7CMr+De+Haviland%7CMrs+Saint+Delafield%7CMrs+Sheppards%7CMukta+Vaani%7CMuli%7CMystery+Quest%7CNTR%7CNeucha%7CNeuton%7CNew+Rocker%7CNews+Cycle%7CNiconne%7CNixie+One%7CNobile%7CNokora%7CNorican%7CNosifer%7CNothing+You+Could+Do%7CNoticia+Text%7CNoto+Sans%7CNoto+Serif%7CNova+Cut%7CNova+Flat%7CNova+Mono%7CNova+Oval%7CNova+Round%7CNova+Script%7CNova+Slim%7CNova+Square%7CNumans%7CNunito%7COdor+Mean+Chey%7COffside%7COld+Standard+TT%7COldenburg%7COleo+Script%7COleo+Script+Swash+Caps%7COpen+Sans%7COpen+Sans+Condensed%7COranienbaum%7COrbitron%7COregano%7COrienta%7COriginal+Surfer%7COswald%7COver+the+Rainbow%7COverlock%7COverlock+SC%7COvo%7COxygen%7COxygen+Mono%7CPT+Mono%7CPT+Sans%7CPT+Sans+Caption%7CPT+Sans+Narrow%7CPT+Serif%7CPT+Serif+Caption%7CPacifico%7CPalanquin%7CPalanquin+Dark%7CPaprika%7CParisienne%7CPassero+One%7CPassion+One%7CPathway+Gothic+One%7CPatrick+Hand%7CPatrick+Hand+SC%7CPattaya%7CPatua+One%7CPavanam%7CPaytone+One%7CPeddana%7CPeralta%7CPermanent+Marker%7CPetit+Formal+Script%7CPetrona%7CPhilosopher%7CPiedra%7CPinyon+Script%7CPirata+One%7CPlaster%7CPlay%7CPlayball%7CPlayfair+Display%7CPlayfair+Display+SC%7CPodkova%7CPoiret+One%7CPoller+One%7CPoly%7CPompiere%7CPontano+Sans%7CPoppins%7CPort+Lligat+Sans%7CPort+Lligat+Slab%7CPragati+Narrow%7CPrata%7CPreahvihear%7CPress+Start+2P%7CPridi%7CPrincess+Sofia%7CProciono%7CPrompt%7CProsto+One%7CProza+Libre%7CPuritan%7CPurple+Purse%7CQuando%7CQuantico%7CQuattrocento%7CQuattrocento+Sans%7CQuestrial%7CQuicksand%7CQuintessential%7CQwigley%7CRacing+Sans+One%7CRadley%7CRajdhani%7CRakkas%7CRaleway%7CRaleway+Dots%7CRamabhadra%7CRamaraja%7CRambla%7CRammetto+One%7CRanchers%7CRancho%7CRanga%7CRasa%7CRationale%7CRavi+Prakash%7CRedressed%7CReem+Kufi%7CReenie+Beanie%7CRevalia%7CRhodium+Libre%7CRibeye%7CRibeye+Marrow%7CRighteous%7CRisque%7CRoboto%7CRoboto+Condensed%7CRoboto+Mono%7CRoboto+Slab%7CRochester%7CRock+Salt%7CRokkitt%7CRomanesco%7CRopa+Sans%7CRosario%7CRosarivo%7CRouge+Script%7CRozha+One%7CRubik%7CRubik+Mono+One%7CRubik+One%7CRuda%7CRufina%7CRuge+Boogie%7CRuluko%7CRum+Raisin%7CRuslan+Display%7CRusso+One%7CRuthie%7CRye%7CSacramento%7CSahitya%7CSail%7CSalsa%7CSanchez%7CSancreek%7CSansita+One%7CSarala%7CSarina%7CSarpanch%7CSatisfy%7CScada%7CScheherazade%7CSchoolbell%7CScope+One%7CSeaweed+Script%7CSecular+One%7CSevillana%7CSeymour+One%7CShadows+Into+Light%7CShadows+Into+Light+Two%7CShanti%7CShare%7CShare+Tech%7CShare+Tech+Mono%7CShojumaru%7CShort+Stack%7CShrikhand%7CSiemreap%7CSigmar+One%7CSignika%7CSignika+Negative%7CSimonetta%7CSintony%7CSirin+Stencil%7CSix+Caps%7CSkranji%7CSlabo+13px%7CSlabo+27px%7CSlackey%7CSmokum%7CSmythe%7CSniglet%7CSnippet%7CSnowburst+One%7CSofadi+One%7CSofia%7CSonsie+One%7CSorts+Mill+Goudy%7CSource+Code+Pro%7CSource+Sans+Pro%7CSource+Serif+Pro%7CSpace+Mono%7CSpecial+Elite%7CSpicy+Rice%7CSpinnaker%7CSpirax%7CSquada+One%7CSree+Krushnadevaraya%7CSriracha%7CStalemate%7CStalinist+One%7CStardos+Stencil%7CStint+Ultra+Condensed%7CStint+Ultra+Expanded%7CStoke%7CStrait%7CSue+Ellen+Francisco%7CSuez+One%7CSumana%7CSunshiney%7CSupermercado+One%7CSura%7CSuranna%7CSuravaram%7CSuwannaphum%7CSwanky+and+Moo+Moo%7CSyncopate%7CTangerine%7CTaprom%7CTauri%7CTaviraj%7CTeko%7CTelex%7CTenali+Ramakrishna%7CTenor+Sans%7CText+Me+One%7CThe+Girl+Next+Door%7CTienne%7CTillana%7CTimmana%7CTinos%7CTitan+One%7CTitillium+Web%7CTrade+Winds%7CTrirong%7CTrocchi%7CTrochut%7CTrykker%7CTulpen+One%7CUbuntu%7CUbuntu+Condensed%7CUbuntu+Mono%7CUltra%7CUncial+Antiqua%7CUnderdog%7CUnica+One%7CUnifrakturCook%7CUnifrakturMaguntia%7CUnkempt%7CUnlock%7CUnna%7CVT323%7CVampiro+One%7CVarela%7CVarela+Round%7CVast+Shadow%7CVesper+Libre%7CVibur%7CVidaloka%7CViga%7CVoces%7CVolkhov%7CVollkorn%7CVoltaire%7CWaiting+for+the+Sunrise%7CWallpoet%7CWalter+Turncoat%7CWarnes%7CWellfleet%7CWendy+One%7CWire+One%7CWork+Sans%7CYanone+Kaffeesatz%7CYantramanav%7CYatra+One%7CYellowtail%7CYeseva+One%7CYesteryear%7CYrsa%7CZeyada&#038;subset=latin%2Clatin-ext'
          type='text/css' media='all'/>
    <link
            href="https://fonts.googleapis.com/css2?family=Berkshire+Swash&family=Elsie+Swash+Caps:wght@400;900&family=Kalam:wght@300;400;700&family=Pacifico&family=Satisfy&display=swap"
            rel="stylesheet"/>
    <script>
        !function (theme, navWidth) {
            if (theme === 'dark') document.documentElement.classList.add('dark-theme')
            if (navWidth) document.documentElement.style.setProperty('--nav-width', `${navWidth}px`)
        }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)') && 'dark'),
            localStorage && localStorage.getItem('nav-width'))
    </script>
    <script>
        function closeOtherDetails(id) {
            const details = document.getElementsByTagName('details');
            for (let i = 0; i < details.length; i++) {
                if (details[i].id !== id) {
                    details[i].removeAttribute('open');
                }
            }
        }
    </script>
    <style>
        @media screen and (min-width: 1025px) {
            .div-to-desk {
                display: none;
                /* Hide the div on screens smaller than 1025px (mobile) */
            }
        }

        @media screen and (max-width: 1025px) {
            .div-to-hide {
                display: none;
                /* Hide the div on screens smaller than 1025px (mobile) */
            }
        }
    </style>
</head>

<body>
<nav class="navbar">
    <div class="navbar-brand">
        <a class="navbar-item" href="../../home.html"> <img width="40" height="25"
                                                            src="../../scripts/images/nani1.png" alt="Home"/>
            <h5 href="../../home.html" class="div-to-hide berkshire-swash-regular">Ravish</h5>
        </a>
        <h4 class="div-to-desk berkshire-swash-regular" href="../../home.html">Ravish</h4>
        <button class="navbar-burger" data-target="topbar-nav">
            <span></span> <span></span> <span></span>
        </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
        <div class="navbar-end">
            <div class="navbar-item" style="text-align: center;">
                <div class="nav-item is-hoverable" style="top: .2rem;"><a class="nav-link"
                                                                          href="../../home.html"><img height="25"
                                                                                                      width="25"
                                                                                                      src="../../scripts/images/home.png"></i>
                </a></div>
                <div class="navbar-item is-hoverable">
                    <a class="navbar-link" href="../../java/introduction.html">Java</a>
                </div>
                <div class="navbar-item is-hoverable">
                    <a class="navbar-link" href="../../spring/introduction.html">Spring</a>
                </div>
                <div class="navbar-item is-hoverable">
                    <a class="navbar-link" href="../../springboot/introduction.html">SpringBoot</a>
                </div>
                <div class="navbar-item is-hoverable">
                    <a class="navbar-link" href="../../microservices/ms-intro.html">Microservices</a>
                </div>
                <div class="navbar-item is-hoverable">
                    <a class="navbar-link" href="../../java/java8/introduction.html">Java 8 Features</a>
                </div>
                <div class="navbar-item is-hoverable">
                    <a class="navbar-link" href="../../DP/introduction.html">Design Patterns</a>
                </div>
                <div class="navbar-item is-hoverable">
                    <a class="navbar-link" href="../../interview/interview-questions.html">Interview Questions</a>
                </div>
                <label class="theme-toggler div-to-hide">
                    <input type="checkbox" id="switch-theme-checkbox"/>
                    <span class="icon"></span>
                </label>
            </div>
        </div>
    </div>
    <label class="theme-toggler div-to-desk" style="top: 22px;">
        <input type="checkbox" id="switch-theme-mobile"/>
        <span class="icon"></span>
    </label>
</nav>

<div class="body">
    <div class="nav-container">
        <aside class="nav">
            <div class="nav-panel-menu is-active" data-panel="menu">
                <li class="nav-item" data-depth="0">
                    <ul class="nav-list">
                        <h4>Interview Questions</h4>
                        <li class="nav-item"><a class="nav-link" href="../java/random.html">Java
                            Core</a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-interview-questions.html">Java
                            Basics</a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-abstraction.html">Java
                            Abstraction</a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-encapsulation.html">Java
                            Encapsulation</a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-polymorphism.html">Java
                            Polymorphism</a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-inheritance.html">Java
                            Inheritance </a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-string.html">Java
                            String</a></li>
                        <li class="nav-item"><a class="nav-link"
                                                href="../java/java-overloading-Overriding.html">Java
                            Overloading and Overriding</a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-exception.html">Java
                            Exception Handling</a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-multithreading.html">Java
                            Multithreading</a></li>
                        <h4> Collections Interview Questions</h4>
                        <li class="nav-item"><a class="nav-link" href="../java/java-collections.html">Java
                            Collections </a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-list.html">Java
                            List </a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-set.html">Java
                            Set </a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/java-map.html">Java
                            Map</a></li>
                        <li class="nav-item"><a class="nav-link" href="../java/miscellaneous.html">Java
                            Advanced</a></li>
                        <h4> Java Programming Interview Questions</h4>
                        <li class="nav-item"><a class="nav-link" href="../java/programs.html">Java
                            Programs </a></li>
                    </ul>
                </li>
            </div>
        </aside>
    </div>
    <main class="article">
        <div class="toolbar">
            <button class="navbar-burger" id="nav-toggle-1">
                <span></span>
                <span></span>
            </button>
            <nav class="breadcrumbs">
                <ul>
                    <li><a href="../../interview/interview-questions.html">Interview Questions</a></li>
                    <li><a href="../java/random.html">Java Interview Questions</a></li>
                </ul>
            </nav>
        </div>
        <div class="doc">
            <nav class="breadcrumbs div-to-hide">
                <ul>
                    <li><a href="../../interview/interview-questions.html">Interview Questions</a></li>
                    <li><a href="../java/random.html">Java Interview Questions</a></li>
                </ul>

            </nav>
            <article>
                <strong><span
                        style="font-size: 12pt; line-height: 115%;">Table of Content:</span></strong>
                <p></p>
                <p style="margin-left: 0.5in;"><a href="#java">1. Java Components Interview Questions</a></p>
                <p style="margin-left: 0.5in;"><a href="#oops">2. Java OOPS Interview Questions</a></p>
                <p style="margin-left: 0.5in;"><a href="#string">3. String and Immutable Interview Questions</a></p>
                <p style="margin-left: 0.5in;"><a href="#exception">4. Exception Handling Interview Questions</a></p>
                <p style="margin-left: 0.5in;"><a href="#multithreading">5. Multithreading Interview Questions</a></p>
                <p style="margin-left: 0.5in;"><a href="#sortings">6. Java Comparable vs Comparator Interview
                    Questions</a></p>
                <p style="margin-left: 0.5in;"><a href="#syncronization">7. Synchronization Interview Questions</a></p>
                <p style="margin-left: 0.5in;"><a href="#serialization">8. Serialization And DeSerialization Interview
                    Questions</a></p>
                <p style="margin-left: 0.5in;"><a href="#miscellaneous">9. Java Miscellaneous Interview Questions</a>
                </p>

                <h1><a name="java">1. Java Components Interview Questions</a></h1>

                <h4>Q1. Can you tell me the difference between JDK, JRE, and JVM?</h4>
                <p><strong>1. JDK (Java Development Kit):</strong></p>
                <ul>
                    <li><strong>Purpose:</strong> The JDK is a complete software development kit that developers use to
                        create Java applications. It includes the JRE, as well as development tools like the <span
                                class="method">Java compiler</span> (<span class="variable">javac</span>), debuggers,
                        and various utilities.
                    </li>
                    <li><strong>Functionality:</strong> The JDK is used to write and compile Java code. When you write
                        Java source code, the JDK’s compiler converts it into bytecode, which can then be executed by
                        the JVM. The JDK also includes tools for debugging, documentation generation, and other
                        development-related tasks.
                    </li>
                </ul>
                <p><strong>Development tools:</strong></p>
                <ul>
                    <li><strong><span class="method">Javac</span>:</strong> The Java compiler converts Java source code
                        (<span class="variable">.java</span> files) into bytecode (<span class="variable">.class</span>
                        files). This bytecode is platform-independent and can be executed by the JVM.
                    </li>
                    <li><strong><span class="method">javadoc</span>:</strong> Generates API documentation from Java
                        source code comments.
                    </li>
                    <li><strong><span class="method">javap</span>:</strong> Class file disassembler, Allows you to view
                        the bytecode of compiled <span class="variable">.class</span> files.
                    </li>
                </ul>
                <p><strong>Debugging tools:</strong></p>
                <ul>
                    <li><strong><span class="method">jdb</span>:</strong> Java Debugger. Used for finding and fixing
                        bugs in Java programs.
                    </li>
                </ul>
                <p><strong>Execution tools:</strong></p>
                <ul>
                    <li><strong><span class="method">jvm launcher</span>, <span class="method">jjs</span> (<span
                            class="variable">jshell</span>):</strong> <span class="method">jjs</span> was a command-line
                        tool introduced in Java 8 as part of the Nashorn JavaScript engine.
                    </li>
                </ul>
                <p><strong>Package tools:</strong></p>
                <ul>
                    <li><strong><span class="method">jar</span>:</strong> Java Archive Tool. Used to package Java
                        classes and resources into a single archive file (<span class="variable">.jar</span>).
                    </li>
                </ul>
                <p><strong>Security tools:</strong></p>
                <ul>
                    <li><strong><span class="method">keytool</span>:</strong> Used for managing cryptographic keys,
                        certificates, and keystores. It's essential for creating and maintaining the security
                        infrastructure needed for Java applications.
                    </li>
                    <li><strong><span class="method">jarsigner</span>:</strong> Used to sign JAR files digitally,
                        ensuring their integrity and authenticity, and to verify those signatures, which is critical for
                        distributing trusted Java applications.
                    </li>
                </ul>
                <p><strong>Monitor & Management tools:</strong></p>
                <ul>
                    <li><strong><span class="method">jconsole</span>:</strong> Provides a graphical interface to monitor
                        and manage Java applications, particularly useful for observing memory usage, CPU consumption,
                        thread usage, and other performance metrics.
                    </li>
                    <li><strong><span class="method">jstack</span>:</strong> The primary use of <span class="method">jstack</span>
                        is to capture the current state of all threads in a JVM. This is particularly useful for
                        diagnosing issues like deadlocks, thread contention, and performance bottlenecks.
                    </li>
                </ul>
                <p><strong>Native Libraries:</strong></p>
                <ul>
                    <li><strong>Use:</strong> The JDK includes native libraries (<span class="variable">.dll</span> on
                        Windows, <span class="variable">.so</span> on Linux, <span class="variable">.dylib</span> on
                        macOS) that provide platform-specific functionality, such as graphics rendering and system
                        interactions.
                    </li>
                </ul>

                <p><strong>2. JRE (Java Runtime Environment):</strong></p>
                <ul>
                    <li><strong>Purpose:</strong> The JRE provides the runtime environment that is needed to run Java
                        applications. It includes the JVM and core standard libraries, supporting API, utilities but
                        does not contain development tools like compilers or debuggers.
                    </li>
                    <li><strong>Functionality:</strong> When you want to run a Java application, the JRE is what you
                        need. It contains everything required to run Java programs, such as the JVM, core libraries, and
                        other components necessary for executing Java applications.
                    </li>
                </ul>
                <p><strong>Components of the JRE:</strong></p>
                <ul>
                    <li><strong>1. <span class="class">Java Virtual Machine</span> (JVM):</strong>
                        <ul>
                            <li>The JVM is the core component of the JRE, responsible for executing Java bytecode. It
                                interprets or compiles the bytecode into native machine code and manages system
                                resources like memory and threads.
                            </li>
                        </ul>
                    </li>
                    <li><strong>2. Java Class Libraries:</strong>
                        <ul>
                            <li>The JRE includes a set of standard Java libraries (also known as the Java API) that
                                provide a wide range of functionalities:
                                <ul>
                                    <li><span class="class">java.lang</span>: Fundamental classes like <span
                                            class="variable">String</span>, <span class="variable">Math</span>, <span
                                            class="variable">System</span>, etc.
                                    </li>
                                    <li><span class="class">java.util</span>: Utility classes like collections (<span
                                            class="variable">lists</span>, <span class="variable">sets</span>, <span
                                            class="variable">maps</span>), date/time, etc.
                                    </li>
                                    <li><span class="class">java.io</span> and <span class="class">java.nio</span>:
                                        Input/output classes for file handling, streams, and networking.
                                    </li>
                                    <li><span class="class">java.net</span>: Classes for networking operations, such as
                                        <span class="variable">sockets</span> and <span class="variable">URLs</span>.
                                    </li>
                                    <li><span class="class">java.sql</span>: Classes for interacting with databases
                                        using <span class="variable">JDBC</span>.
                                    </li>
                                    <li><span class="class">javax.*</span>: Extensions to the core libraries, including
                                        GUI components (<span class="class">Swing</span>), XML processing, etc.
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>3. Class Loader:</strong>
                        <ul>
                            <li>The class loader is part of the JVM but integral to the JRE's operation. It loads Java
                                classes into memory as they are needed, ensuring that the correct classes are available
                                for execution.
                            </li>
                        </ul>
                    </li>
                    <li><strong>4. Java Plugin (for web browsers):</strong>
                        <ul>
                            <li><strong>Note:</strong> This component is mostly obsolete due to the deprecation of
                                applets.
                            </li>
                            <li>The Java plugin allows Java applets to run within web browsers, although modern browsers
                                have largely phased out support for this due to security concerns.
                            </li>
                        </ul>
                    </li>
                    <li><strong>5. Java Web Start:</strong>
                        <ul>
                            <li><strong>Note:</strong> Also deprecated in newer Java versions.</li>
                            <li>This component allowed the launching of Java applications directly from the web without
                                the need to manually download and install them. It provided a way to deploy Java
                                applications over a network.
                            </li>
                        </ul>
                    </li>
                </ul>

                <p><strong>3. JVM (Java Virtual Machine):</strong></p>
                <ul>
                    <li><strong>Purpose:</strong> JVM is a core component of the Java programming language, responsible
                        for executing Java bytecode on any device or operating system. It acts as an intermediary
                        between the compiled Java program and the underlying hardware and operating system, enabling
                        Java's platform independence—"write once, run anywhere”.
                    </li>
                    <li><strong>Functionality:</strong> It interprets the compiled Java bytecode (from <span
                            class="variable">.class</span> files) and translates it into machine code, which is then
                        executed by the computer's CPU. The JVM also handles system-level tasks such as memory
                        management, garbage collection, and thread management.
                    </li>
                </ul>
                <p><strong>Use and Importance of the JVM:</strong></p>
                <ul>
                    <li><strong>Platform Independence:</strong> The JVM enables Java's "write once, run anywhere"
                        capability by abstracting the underlying hardware and operating system differences.
                    </li>
                    <li><strong>Loading Code:</strong> The JVM loads <span class="variable">.class</span> files
                        (compiled Java bytecode) into memory. This is done by the <span
                                class="class">class loader</span> subsystem of the JVM, which finds and loads the class
                        files at runtime.
                    </li>
                    <li><strong>Bytecode Verification:</strong> The JVM verifies the bytecode to ensure it adheres to
                        Java's security and format rules before execution. This prevents malicious code from being
                        executed.
                    </li>
                    <li><strong>Execution of Code:</strong> The JVM interprets or compiles the bytecode to native
                        machine code using either an <span class="method">interpreter</span> or the <span
                                class="method">Just-In-Time (JIT)</span> compiler. This native code is what gets
                        executed by the underlying operating system.
                    </li>
                    <li><strong>Memory Management:</strong> The JVM automates memory management and garbage collection,
                        reducing the risk of memory leaks and other memory-related issues.
                    </li>
                    <li><strong>Security:</strong> The JVM provides a controlled and secure execution environment,
                        making it a reliable platform for running potentially untrusted code.
                    </li>
                    <li><strong>Performance Optimization:</strong> With components like the JIT compiler, the JVM
                        optimizes performance, making Java applications run efficiently across various platforms.
                    </li>
                    <li><strong>Multithreading:</strong> The JVM manages multiple threads within a single Java program,
                        allowing for efficient multitasking and parallel processing.
                    </li>
                </ul>
                <p><strong>Summary:</strong></p>
                <ul>
                    <li><strong>JVM:</strong> Executes Java bytecode on any platform.</li>
                    <li><strong>JRE:</strong> Runs Java applications (includes JVM + libraries).</li>
                    <li><strong>JDK:</strong> Develops Java applications (includes JRE + development tools).</li>
                </ul>

                <h4>Q2. What are the key components of JVM Architecture?</h4>
                <p>The Java Virtual Machine (JVM) architecture is designed to provide a runtime environment for Java
                    applications. It abstracts the underlying hardware and operating system to allow Java programs to
                    run on any device that has a compatible JVM installed. Here’s a detailed breakdown of the JVM
                    architecture and its components:</p>
                <p><strong>1. Class Loader Subsystem</strong></p>
                <ul>
                    <li><strong>1. Loading:</strong> Class files (typically <span class="variable">.class</span> files)
                        are loaded into the JVM by the <span class="class">class loader</span>. The Class Loader
                        Subsystem is responsible for loading, linking, and initializing classes.
                        <ul>
                            <li><strong>Bootstrap Class Loader:</strong> This is the root class loader that loads core
                                Java classes from the Java standard library (rt.jar or equivalent in newer versions). It
                                is part of the JVM implementation and is responsible for loading fundamental classes
                                like <span class="class">java.lang.Object</span>.
                            </li>
                            <li><strong>Extension Class Loader:</strong> The <span
                                    class="class">Extension ClassLoader</span> is responsible for loading classes from
                                the JRE’s lib/ext directory and any other directories specified by the <span
                                        class="variable">java.ext.dirs</span> system property.
                            </li>
                            <li><strong>Application Class Loaders:</strong> The <span class="class">Application ClassLoader</span>
                                is responsible for loading classes from the application's classpath. It is the default
                                class loader for most applications and is used to load classes specified by the <span
                                        class="variable">CLASSPATH</span> environment variable or <span
                                        class="variable">-cp</span> option in the command line. It handles the loading
                                of application-specific classes and libraries.
                            </li>
                        </ul>
                    </li>
                    <li><strong>2. Linking:</strong> The linking process involves verification (checking the correctness
                        of the bytecode), preparation (resolving symbolic references), and optionally, resolution
                        (replacing symbolic references with direct references).
                        <ul>
                            <li><strong>Verification:</strong>
                                <ul>
                                    <li>Ensures bytecode adheres to JVM specifications and is free of structural and
                                        semantic errors.
                                    </li>
                                    <li>Performed by the bytecode verifier.</li>
                                    <li>Verification ensures that the bytecode of a class file is structurally and
                                        semantically correct and adheres to the JVM specification. This step is crucial
                                        for maintaining the integrity and security of the Java application.
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Preparation:</strong>
                                <ul>
                                    <li>Allocates memory for static fields and initializes them to default values.</li>
                                    <li>Static fields are set to their default values, but static blocks are not
                                        executed.
                                    </li>
                                    <li>Preparation involves allocating memory for class variables (static fields) and
                                        initializing them to default values. This step prepares the class for use by the
                                        JVM and ensures that static variables are ready for use when the class is first
                                        accessed.
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Resolution:</strong>
                                <ul>
                                    <li>Converts symbolic references in the constant pool into direct references.</li>
                                    <li>Ensures that classes, methods, and fields are correctly linked and accessible.
                                    </li>
                                    <li>Resolution involves converting symbolic references in the constant pool of the
                                        class file into direct references. This step ensures that the JVM can correctly
                                        link methods and fields referenced by the class.
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>3. Initialization:</strong> Class initialization involves setting up static variables
                        and executing static blocks.
                        <ul>
                            <li>The initialization phase sets up the class and its static members. This involves
                                executing static initializers (static blocks) and assigning initial values to static
                                fields that have been explicitly defined in the class code.
                            </li>
                        </ul>
                    </li>
                </ul>

                <p><strong>2. Runtime Data Areas</strong></p>
                <p><strong>Function:</strong> The Runtime Data Areas are used by the JVM to manage memory and execution
                    state, these areas handle different types of data and memory management during the execution of Java
                    programs.</p>
                <ul>
                    <li><strong>Method Area:</strong>
                        <ul>
                            <li>Stores class-level data, such as class definitions, method data, and constants. It is
                                shared among all threads.
                            </li>
                            <li>Contains information about classes, interfaces, methods, and fields, as well as runtime
                                constant pools.
                            </li>
                            <li><strong>Class Data:</strong> Information about the <span class="class">Example</span>
                                class, including its superclass (<span class="class">java.lang.Object</span>), its
                                static fields (<span class="variable">count</span>), and instance fields (<span
                                        class="variable">value</span>).
                            </li>
                            <li><strong>Method Data:</strong> Bytecode for <span class="method">printValue()</span> and
                                <span class="method">printCount()</span>.
                            </li>
                            <li><strong>Constant Pool:</strong> String literals like "Static block executed", "Value: ",
                                and "Count: "; references to <span class="variable">System.out.println()</span> and
                                class methods/fields.
                            </li>
                        </ul>
                    </li>
                    <li><strong>1. Class Data:</strong>
                        <ul>
                            <li><strong>Class Definitions:</strong> Includes information about the class itself, such as
                                its name, superclass, interfaces it implements, and its constant pool.
                            </li>
                            <li><strong>Field Data:</strong> Metadata about class fields, including field names, types,
                                and modifiers.
                            </li>
                            <li><strong>Method Data:</strong> Metadata about methods, including method names,
                                signatures, and bytecode instructions.
                            </li>
                            <li><strong>Method Information:</strong> Bytecode of methods and their associated
                                attributes.
                            </li>
                        </ul>
                    </li>
                    <li><strong>2. Constant Pool:</strong>
                        <ul>
                            <li><strong>Constants:</strong> Stores constants used by the class, such as string literals,
                                numeric values, and class references.
                            </li>
                            <li><strong>Symbolic References:</strong> References to classes, methods, and fields in the
                                form of symbolic names, which are resolved to direct references during the class loading
                                process.
                            </li>
                        </ul>
                    </li>
                    <li><strong>3. Static Variables:</strong>
                        <ul>
                            <li><strong>Static Fields:</strong> Allocated space for class-level variables, which are
                                shared among all instances of the class. Static fields are initialized when the class is
                                loaded.
                            </li>
                        </ul>
                    </li>
                    <li><strong>4. Runtime Constant Pool:</strong>
                        <ul>
                            <li><strong>Linking Information:</strong> Contains information used for linking classes,
                                such as method and field references that need to be resolved.
                            </li>
                        </ul>
                    </li>
                </ul>

                <p><strong>Heap Area:</strong></p>
                <ul>
                    <li>The heap is where all Java objects and arrays are allocated.</li>
                    <li>It is managed by the garbage collector, which reclaims memory used by objects that are no longer
                        reachable.
                    </li>
                    <li>The heap is divided into different generations: Young Generation (where new objects are
                        allocated), Old Generation (where long-lived objects are promoted), and sometimes a Permanent
                        Generation (or Metaspace in recent JDK versions) for class metadata.
                    </li>
                    <li><strong>What’s Stored in the Heap:</strong>
                        <ul>
                            <li>Objects: <span class="variable">obj1</span> and <span class="variable">obj2</span>
                                instances of <span class="class">Example</span>, and the array <span class="variable">numbers</span>
                                are stored in the heap.
                            </li>
                            <li>Garbage Collection: If <span class="variable">obj1</span> is no longer referenced, it
                                will be eligible for garbage collection.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Generations:</strong> The heap is often divided into generations to optimize garbage
                        collection:
                        <ul>
                            <li><strong>Young Generation:</strong> Where new objects are allocated. It includes:
                                <ul>
                                    <li><strong>Eden Space:</strong> Where new objects are initially allocated.</li>
                                    <li><strong>Survivor Spaces (S0 and S1):</strong> Where objects that survive garbage
                                        collection in the Eden space are moved.
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Old Generation (Tenured Generation):</strong> Where long-lived objects are
                                eventually moved. This space is collected less frequently.
                            </li>
                            <li><strong>Permanent Generation (Pre-JDK 8) / Metaspace (JDK 8+):</strong> Used for storing
                                class metadata, though it's separate from the main heap in JDK 8 and later.
                            </li>
                        </ul>
                    </li>
                </ul>

                <p><strong>Java Stack:</strong></p>
                <ul>
                    <li>Each thread has its own stack that stores frames. Each frame represents a method call and
                        contains local variables, operand stacks, and method call information.
                    </li>
                    <li>The stack keeps track of method invocations and their corresponding variables and intermediate
                        values.
                    </li>
                    <li><strong>What’s Stored in the Stack:</strong>
                        <ul>
                            <li><strong>Frames:</strong>
                                <ul>
                                    <li>For <span class="method">main()</span>: Contains local variables <span
                                            class="variable">obj</span> and the reference to <span class="method">calculate()</span>.
                                    </li>
                                    <li>For <span class="method">calculate()</span>: Contains local variables <span
                                            class="variable">a</span>, <span class="variable">b</span>, and <span
                                            class="variable">sum</span>, and the operand stack for computation.
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>Program Counter (PC) Register:</strong>
                        <ul>
                            <li>Each thread has its own PC register that holds the address of the current instruction
                                being executed.
                            </li>
                            <li>It helps the JVM keep track of which instruction to execute next in the method.</li>
                        </ul>
                    </li>
                    <li><strong>Native Method Stack:</strong>
                        <ul>
                            <li>This stack is used for managing native (non-Java) method calls made by Java code, which
                                interact with libraries written in languages like C or C++.
                            </li>
                            <li>It works similarly to the Java stack but is used specifically for native methods.</li>
                        </ul>
                    </li>
                </ul>

                <p><strong>3. Execution Engine</strong></p>
                <p><strong>Function:</strong> The Execution Engine is responsible for executing Java bytecode.</p>
                <ul>
                    <li><strong>Interpreter:</strong>
                        <ul>
                            <li>Reads and executes bytecode instructions one at a time.</li>
                            <li>It is simpler and provides immediate feedback during execution, but it may be slower
                                than the JIT compiler.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Just-In-Time (JIT) Compiler:</strong>
                        <ul>
                            <li>Converts bytecode into native machine code at runtime, improving performance by
                                eliminating the need to interpret bytecode repeatedly.
                            </li>
                            <li>The JIT compiler optimizes the code and compiles frequently executed methods (hotspots)
                                into native code, which is then directly executed by the CPU.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Garbage Collector:</strong>
                        <ul>
                            <li>The Garbage Collector (GC) in the Java Virtual Machine (JVM) is responsible for
                                automatically managing memory by reclaiming space from objects that are no longer in
                                use. The primary goal of GC is to free up memory and improve application performance by
                                removing unused objects.
                            </li>
                            <li>Various garbage collection algorithms (e.g., generational, parallel, concurrent) are
                                used to optimize memory management and minimize pauses during application execution.
                            </li>
                        </ul>
                    </li>
                </ul>

                <p><strong>4. Native Interface</strong></p>
                <p><strong>Function:</strong> The Native Interface allows Java code to interact with native applications
                    and libraries written in languages like C or C++.</p>
                <ul>
                    <li><strong>Java Native Interface (JNI):</strong>
                        <ul>
                            <li>A framework that provides a way for Java code running in the JVM to interact with
                                applications and libraries written in other languages.
                            </li>
                            <li>JNI allows Java programs to call native methods and pass data between Java and native
                                code.
                            </li>
                        </ul>
                    </li>
                </ul>

                <p><strong>5. Native Method Libraries</strong></p>
                <p><strong>Function:</strong> These libraries contain native code used by the JVM for interacting with
                    the host operating system.</p>
                <ul>
                    <li><strong>Platform-Specific Libraries:</strong>
                        <ul>
                            <li>Libraries that are specific to the underlying operating system and hardware platform.
                            </li>
                            <li>They include functions for performing low-level operations such as file I/O, threading,
                                and network communication.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h4>Q3. Can a Java application be run without installing the JRE?</h4>
                <p>We can't run a Java application without having the <span class="variable">JRE (Java Runtime Environment)</span>
                    because it has the essential tools and libraries the application needs to work. But, there's a cool
                    tool called <span class="method">jlink</span> in newer Java versions that lets us bundle our Java
                    application with its own little version of the JRE.</p>

                <h4>Q4. Is it possible to have the JDK installed without having the JRE?</h4>
                <p>Yes, it is possible to have the <span class="variable">Java Development Kit (JDK)</span> installed
                    without having a separate <span class="variable">Java Runtime Environment (JRE)</span> installation.
                    In fact, in more recent versions of the JDK, starting from JDK 11, the JRE is no longer provided as
                    a separate download because the JDK includes everything necessary to both develop and run Java
                    applications.</p>

                <h4>Q5. Detailed Overview of the Garbage Collector?</h4>
                <p><strong>1. Purpose:</strong></p>
                <ul>
                    <li><strong>Automatic Memory Management:</strong> GC handles the deallocation of memory that is no
                        longer reachable, reducing the need for manual memory management.
                    </li>
                    <li><strong>Avoid Memory Leaks:</strong> By reclaiming unused memory, GC helps in preventing memory
                        leaks where memory is not properly released.
                    </li>
                </ul>

                <h4>Q6. Types of Garbage Collection Algorithms:</h4>
                <ul>
                    <li><strong>Mark-and-Sweep:</strong> Identifies live objects (mark phase) and then removes the dead
                        objects (sweep phase).
                    </li>
                    <li><strong>Generational Garbage Collection:</strong> Divides the heap into different generations
                        (Young Generation, Old Generation) and applies different collection strategies to each.
                    </li>
                    <li><strong>Stop-the-World:</strong> GC events where all application threads are paused while
                        garbage collection takes place.
                    </li>
                    <li><strong>Concurrent Garbage Collection:</strong> GC runs concurrently with the application
                        threads to minimize pause times.
                    </li>
                </ul>

                <h4>Q7. Major Garbage Collection Algorithms in the JVM:</h4>
                <ul>
                    <li><strong>Serial Garbage Collector:</strong>
                        <ul>
                            <li><strong>Description:</strong> A simple and single-threaded garbage collector suitable
                                for small applications or single-threaded environments.
                            </li>
                            <li><strong>Generations:</strong> Uses a generational approach with Young and Old
                                generations.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Parallel Garbage Collector:</strong>
                        <ul>
                            <li><strong>Description:</strong> Uses multiple threads for garbage collection, improving
                                performance for multi-threaded applications.
                            </li>
                            <li><strong>Generations:</strong> Uses a generational approach with Young and Old
                                generations.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Concurrent Mark-Sweep (CMS) Garbage Collector:</strong>
                        <ul>
                            <li><strong>Description:</strong> Aims to minimize pause times by performing most of the
                                garbage collection concurrently with the application threads.
                            </li>
                            <li><strong>Generations:</strong> Uses Young and Old generations.</li>
                        </ul>
                    </li>
                    <li><strong>G1 (Garbage-First) Garbage Collector:</strong>
                        <ul>
                            <li><strong>Description:</strong> Designed to handle large heaps and provides predictable
                                pause times by dividing the heap into regions and collecting them in a way that
                                prioritizes areas with the most garbage.
                            </li>
                            <li><strong>Generations:</strong> Uses a region-based approach, which includes Young and Old
                                generations within these regions.
                            </li>
                        </ul>
                    </li>
                    <li><strong>ZGC (Z Garbage Collector):</strong>
                        <ul>
                            <li><strong>Description:</strong> A low-latency garbage collector designed for large heaps
                                and provides very low pause times.
                            </li>
                            <li><strong>Generations:</strong> Uses a concurrent approach with multiple generations.</li>
                        </ul>
                    </li>
                    <li><strong>Shenandoah Garbage Collector:</strong>
                        <ul>
                            <li><strong>Description:</strong> A low-latency garbage collector that aims to reduce pause
                                times by performing most of the garbage collection work concurrently.
                            </li>
                            <li><strong>Generations:</strong> Uses a generational approach with Young and Old
                                generations.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h4>Q8. How Garbage Collection Works:</h4>
                <ul>
                    <li><strong>Young Generation Collection:</strong>
                        <ul>
                            <li><strong>Eden Space:</strong> New objects are allocated here. Minor GC occurs when Eden
                                Space becomes full.
                            </li>
                            <li><strong>Survivor Spaces:</strong> Objects that survive minor GC are moved to Survivor
                                Spaces. If they survive multiple GCs, they are eventually promoted to the Old
                                Generation.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Old Generation Collection:</strong>
                        <ul>
                            <li><strong>Major GC (Full GC):</strong> Occurs less frequently and is responsible for
                                collecting long-lived objects in the Old Generation. It is usually more time-consuming.
                            </li>
                        </ul>
                    </li>
                    <li><strong>GC Phases:</strong>
                        <ul>
                            <li><strong>Mark Phase:</strong> Identifies which objects are reachable.</li>
                            <li><strong>Sweep Phase:</strong> Reclaims the memory of unreachable objects.</li>
                            <li><strong>Compact Phase:</strong> (Optional) Rearranges objects to reduce fragmentation.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h3>Example of Garbage Collection in Action:</h3>
                <div>
                    <p>• In this example, each iteration creates a new large array, and once the loop is complete, those
                        arrays become unreachable.</p>
                    <p>• Calling <span class="method">System.gc()</span> suggests to the JVM to perform garbage
                        collection, although the exact timing and execution of GC are controlled by the JVM.</p>
                    <p>• Young Generation Collection: The large arrays are initially allocated in the Eden Space and
                        collected during minor GC.</p>
                    <p>• Old Generation Collection: If objects are promoted to the Old Generation and are no longer in
                        use, they will be collected during major GC.</p>
                </div>

                <h4>Q9. What is the purpose of the Garbage Collector in the JVM?</h4>
                <p>The Garbage Collector (GC) automatically manages memory by reclaiming space from objects that are no
                    longer reachable or used, helping to prevent memory leaks and optimize memory usage.</p>

                <h4>Q10. Explain the difference between the Young Generation and the Old Generation in the heap.</h4>
                <p>The Young Generation is where new objects are allocated and collected. It consists of Eden Space and
                    Survivor Spaces. The Old Generation is where long-lived objects are moved after surviving multiple
                    GCs. Major GC (Full GC) deals with the Old Generation.</p>

                <h4>Q11. What is a memory leak, and how can it be detected in a Java application?</h4>
                <p>A memory leak occurs when objects are unintentionally retained in memory, preventing their garbage
                    collection. Memory leaks can be detected using profiling tools, heap dumps, and analyzing object
                    references to identify and address leaks.</p>

                <h4>Q12. What are the main types of garbage collectors available in the JVM?</h4>
                <p>The main types include:</p>
                <ul>
                    <li><strong>Serial Garbage Collector</strong></li>
                    <li><strong>Parallel Garbage Collector (Throughput Collector)</strong></li>
                    <li><strong>Concurrent Mark-Sweep (CMS) Collector</strong></li>
                    <li><strong>G1 Garbage Collector</strong></li>
                </ul>

                <h4>Q13. How does the G1 Garbage Collector work, and when should it be used?</h4>
                <p>The G1 Garbage Collector divides the heap into regions and performs garbage collection with a focus
                    on meeting application pause time goals. It is suitable for applications with large heaps and those
                    requiring predictable pause times.</p>

                <h4>Q14. What is the difference between minor GC and major GC?</h4>
                <p>Minor GC (or Young GC) deals with the Young Generation, collecting objects from Eden Space and
                    Survivor Spaces. Major GC (or Full GC) deals with the Old Generation, reclaiming memory from
                    long-lived objects and potentially performing full heap collections.</p>

                <h4>Q15. What is a Stop-the-World event, and how does it impact application performance?</h4>
                <p>A Stop-the-World event occurs when the JVM pauses all application threads to perform garbage
                    collection. This can impact application performance by causing latency and unresponsiveness during
                    the collection process.</p>

                <h4>Q16. How can you tune garbage collection in a Java application?</h4>
                <p>GC tuning involves adjusting JVM options related to heap size, garbage collection algorithms, and
                    pause time goals. Key options include <span class="variable">-Xms</span> (initial heap size), <span
                            class="variable">-Xmx</span> (maximum heap size), and specific GC flags like <span
                            class="variable">-XX:+UseG1GC</span> or <span
                            class="variable">-XX:+UseConcMarkSweepGC</span>.</p>

                <h4>Q17. Explicit GC Requests and finalize method?</h4>
                <ul>
                    <li><strong>System.gc():</strong> This method suggests that the JVM perform garbage collection. It
                        is a request rather than a guarantee, and the JVM may choose to ignore it or perform GC at a
                        later time.
                    </li>
                    <li><strong>Runtime.getRuntime().gc():</strong> This is another way to suggest that garbage
                        collection be performed. It’s essentially a wrapper around <span
                                class="method">System.gc()</span>.
                    </li>
                </ul>
                <p>The <span class="method">finalize()</span> method in Java is a mechanism that allows an object to
                    perform cleanup operations before it is removed from memory by the Garbage Collector (GC). It is
                    defined in the <span class="class">java.lang.Object</span> class and can be overridden by subclasses
                    to release resources or perform other cleanup tasks.</p>
                <p><strong>Deprecated in Java 9+:</strong> The <span class="method">finalize()</span> method has been
                    deprecated in Java 9 and later versions in favor of more robust resource management techniques, such
                    as <span class="method">try-with-resources</span> and <span class="class">Cleaner</span> class.</p>

                <h1><a name="oops">2. Java OOPS Interview Questions</a></h1>
                <h4>1. Class</h4>
                <p>A <strong>class</strong> in Java is a blueprint or template that defines the structure and behaviour
                    (data and methods) of objects. It serves as a prototype for creating objects. A class defines:</p>
                <ul>
                    <li><strong>Attributes (Fields)</strong>: Variables that hold the state or data of the class.</li>
                    <li><strong>Methods</strong>: Functions or procedures that define the behaviours or actions that the
                        class can perform.
                    </li>
                </ul>
                <h3>Key Points:</h3>
                <ul>
                    <li><strong>Encapsulation</strong>: Classes encapsulate data (fields) and methods that operate on
                        the data.
                    </li>
                    <li><strong>Access Modifiers</strong>: Fields and methods can have access modifiers (e.g., <span
                            class="keyword">private</span>, <span class="keyword">public</span>, <span class="keyword">protected</span>)
                        that control their visibility.
                    </li>
                    <li><strong>Constructor</strong>: Special method used to initialize objects of the class.</li>
                </ul>

                <h4>2. Object</h4>
                <p>An <strong>object</strong> is an instance of a class. It represents a concrete entity based on the
                    blueprint provided by the class. Each object has its own set of attributes and can perform actions
                    defined by the class methods.</p>
                <h3>Key Points:</h3>
                <ul>
                    <li><strong>Instantiation</strong>: Objects are created using the <span class="keyword">new</span>
                        keyword followed by the class constructor.
                    </li>
                    <li><strong>State and Behavior</strong>: Each object has its own state (attributes) and can invoke
                        methods to perform actions.
                    </li>
                    <li><strong>Encapsulation</strong>: Objects encapsulate data and provide methods to access and
                        modify the data.
                    </li>
                </ul>

                <h4>3. Abstraction</h4>
                <p><strong>Abstraction</strong> is the concept of hiding the complex implementation details and showing
                    only the essential features of an object. It allows a focus on what an object does rather than how
                    it does it.</p>
                <h3>Key Points:</h3>
                <ul>
                    <li><strong>Abstract Classes</strong>: Classes that cannot be instantiated and may contain abstract
                        methods (methods without implementation).
                    </li>
                    <li><strong>Interfaces</strong>: Define a contract for what a class can do, without specifying how
                        it does it.
                    </li>
                </ul>
                <h3>Example:</h3>
                <p><strong>Use Case:</strong></p>
                <ul>
                    <li><strong>Simplified Interface</strong>: Allows users to interact with complex systems using
                        simple interfaces.
                    </li>
                    <li><strong>Decoupling</strong>: Helps in separating the abstract properties from the implementation
                        details.
                    </li>
                </ul>

                <h4>4. Encapsulation</h4>
                <p><strong>Encapsulation</strong> is the concept of bundling data (variables) and methods (functions)
                    that operate on the data into a single unit, usually a class. It hides the internal state of the
                    object and requires all interaction to be performed through an object’s methods.</p>
                <h3>Key Points:</h3>
                <ul>
                    <li><strong>Access Modifiers</strong>: Control access to the data and methods (e.g., <span
                            class="keyword">private</span>, <span class="keyword">protected</span>, <span
                            class="keyword">public</span>).
                    </li>
                    <li><strong>Getter and Setter Methods</strong>: Provide controlled access to the private fields.
                    </li>
                </ul>
                <h3>Example:</h3>
                <p><strong>Use Case:</strong></p>
                <ul>
                    <li><strong>Data Security</strong>: Protects the internal state of an object from unwanted
                        modifications.
                    </li>
                    <li><strong>Maintainability</strong>: Allows changes to the internal implementation without
                        affecting the external interface.
                    </li>
                </ul>

                <h4>5. Polymorphism</h4>
                <p><strong>Polymorphism</strong> in Java is a core concept in object-oriented programming (OOP) that
                    allows one interface to be used for a general class of actions. The specific action is determined by
                    the exact nature of the situation. This means that polymorphism allows objects of different classes
                    to be treated as objects of a common superclass. It supports method overriding and method
                    overloading, which are the two main types of polymorphism in Java.</p>
                <h3>Types of Polymorphism</h3>
                <ol>
                    <li><strong>Compile-Time Polymorphism (Method Overloading)</strong>
                        <ul>
                            <li><strong>Method Overloading</strong>: Multiple methods with the same name but different
                                parameters within the same class.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Run-Time Polymorphism (Method Overriding)</strong>
                        <ul>
                            <li><strong>Method Overriding</strong>: A subclass provides a specific implementation of a
                                method that is already defined in its superclass.
                            </li>
                        </ul>
                    </li>
                </ol>

                <h3>Examples</h3>
                <h4>1. Compile-Time Polymorphism (Method Overloading)</h4>
                <div class="code">
                    <span class="keyword">public</span> <span class="keyword">class</span> <span class="class">PolymorphismDemo</span>
                    {
                    <br><br>
                    <span class="keyword">public</span> <span class="keyword">void</span> <span
                        class="method">display</span>(<span class="keyword">int</span> <span class="variable">a</span>)
                    {
                    <br> <span class="keyword">System</span>.<span class="method">out</span>.<span class="method">println</span>(<span
                        class="string">"Integer: "</span> + <span class="variable">a</span>);
                    <br>}
                    <br><br>
                    <span class="keyword">public</span> <span class="keyword">void</span> <span
                        class="method">display</span>(<span class="keyword">String</span> <span
                        class="variable">a</span>, <span class="keyword">int</span> <span class="variable">b</span>) {
                    <br> <span class="keyword">System</span>.<span class="method">out</span>.<span class="method">println</span>(<span
                        class="string">"String and Integer: "</span> + <span class="variable">a</span> + <span
                        class="string">", "</span> + <span class="variable">b</span>);
                    <br>}
                    <br><br>
                    <span class="keyword">public static void</span> <span class="method">main</span>(<span
                        class="keyword">String</span>[] <span class="variable">args</span>) {
                    <br> <span class="class">PolymorphismDemo</span> <span class="variable">obj</span> = <span
                        class="keyword">new</span> <span class="class">PolymorphismDemo</span>();
                    <br> <span class="variable">obj</span>.<span class="method">display</span>(<span
                        class="number">10</span>); <span class="comment">// Calls method with int parameter</span>
                    <br> <span class="variable">obj</span>.<span class="method">display</span>(<span class="string">"Hello"</span>,
                    <span class="number">20</span>); <span class="comment">// Calls method with String and int parameters</span>
                    <br>}
                    <br>}
                </div>

                <h4>2. Run-Time Polymorphism (Method Overriding)</h4>
                <div class="code">
                    <span class="keyword">class</span> <span class="class">Animal</span> {
                    <br><br>
                    <span class="keyword">public</span> <span class="keyword">void</span> <span
                        class="method">makeSound</span>() {
                    <br> <span class="keyword">System</span>.<span class="method">out</span>.<span class="method">println</span>(<span
                        class="string">"Animal makes a sound"</span>);
                    <br>}
                    <br>}
                    <br><br>
                    <span class="keyword">class</span> <span class="class">Dog</span> <span
                        class="keyword">extends</span> <span class="class">Animal</span> {
                    <br><br>
                    <span class="keyword">@Override</span>
                    <br><span class="keyword">public</span> <span class="keyword">void</span> <span class="method">makeSound</span>()
                    {
                    <br> <span class="keyword">System</span>.<span class="method">out</span>.<span class="method">println</span>(<span
                        class="string">"Dog barks"</span>);
                    <br>}
                    <br>}
                    <br><br>
                    <span class="keyword">class</span> <span class="class">Cat</span> <span
                        class="keyword">extends</span> <span class="class">Animal</span> {
                    <br><br>
                    <span class="keyword">@Override</span>
                    <br><span class="keyword">public</span> <span class="keyword">void</span> <span class="method">makeSound</span>()
                    {
                    <br> <span class="keyword">System</span>.<span class="method">out</span>.<span class="method">println</span>(<span
                        class="string">"Cat meows"</span>);
                    <br>}
                    <br>}
                    <br><br>
                    <span class="keyword">public class</span> <span class="class">PolymorphismDemo</span> {
                    <br><br>
                    <span class="keyword">public static void</span> <span class="method">main</span>(<span
                        class="keyword">String</span>[] <span class="variable">args</span>) {
                    <br> <span class="keyword">Animal</span> <span class="variable">myAnimal</span>;
                    <br><br>
                    <span class="variable">myAnimal</span> = <span class="keyword">new</span> <span
                        class="class">Dog</span>();
                    <br> <span class="variable">myAnimal</span>.<span class="method">makeSound</span>(); <span
                        class="comment">// Output: Dog barks</span>
                    <br><br>
                    <span class="variable">myAnimal</span> = <span class="keyword">new</span> <span
                        class="class">Cat</span>();
                    <br> <span class="variable">myAnimal</span>.<span class="method">makeSound</span>(); <span
                        class="comment">// Output: Cat meows</span>
                    <br>}
                    <br>}
                </div>

                <h4>6. Inheritance</h4>
                <p><strong>Inheritance</strong> is the mechanism by which one class (subclass or derived class) acquires
                    the properties and behaviors of another class (superclass or base class). It promotes code
                    reusability and establishes a hierarchical relationship between classes.</p>
                <h3>Key Points:</h3>
                <ul>
                    <li><strong>extends Keyword</strong>: Used to define inheritance.</li>
                    <li><strong>Method Overriding</strong>: Allows subclasses to provide a specific implementation of a
                        method that is already defined in its superclass.
                    </li>
                </ul>
                <h3>Why multiple inheritance is not possible in Java?</h3>
                <p>Java avoids using multiple inheritance because it can make things complicated, such as when two
                    parent classes have methods that conflict.</p>
                <h3>Example:</h3>
                <p><strong>Use Case:</strong></p>
                <ul>
                    <li><strong>Code Reusability</strong>: Allows you to reuse existing code without rewriting it.</li>
                    <li><strong>Polymorphism</strong>: Enables objects of different classes to be treated as objects of
                        a common superclass.
                    </li>
                </ul>
                <p>In object-oriented programming, especially in Java, understanding the relationships between classes
                    is crucial for designing complex systems. Association, Aggregation, and Composition are three types
                    of relationships that define how objects of different classes interact with each other.</p>
                <h4>7. Association</h4>
                <p><strong>Definition:</strong> Association represents a general relationship between two or more classes. It indicates how objects of one class are related to objects of another class. This relationship can be one-to-one, one-to-many, many-to-one, or many-to-many.</p>
                <h3>Key Points:</h3>
                <ul>
                    <li><strong>Bidirectional or Unidirectional:</strong> Association can be either bidirectional (both classes are aware of each other) or unidirectional (one class is aware of the other).</li>
                    <li><strong>Lifetime Independence:</strong> Objects involved in an association relationship can exist independently of each other.</li>
                </ul>
                <h3>Example:</h3>
                <p><strong>Use Case:</strong></p>
                <ul>
                    <li><strong>One-to-Many Relationship:</strong> A student can be enrolled in multiple courses, and a course can have multiple students. The relationship between Student and Course is a simple association.</li>
                </ul>

                <h4>8. Aggregation</h4>
                <p><strong>Definition:</strong> Aggregation represents a "whole-part" relationship where the part can exist independently of the whole. It implies that one class (the whole) contains another class (the part), but the lifecycle of the part is not strictly tied to the lifecycle of the whole.</p>
                <h3>Key Points:</h3>
                <ul>
                    <li><strong>Weak Relationship:</strong> The lifecycle of the aggregated objects is independent of the parent object.</li>
                    <li><strong>Ownership:</strong> The whole class contains a reference to the part class, but the part class can be shared or used by other classes.</li>
                </ul>
                <h3>Example:</h3>
                <p><strong>Use Case:</strong></p>
                <ul>
                    <li><strong>Whole-Part Relationship:</strong> A Department contains multiple Teacher objects, but a Teacher can exist independently of any Department and can be associated with multiple departments.</li>
                </ul>

                <h4>9. Composition</h4>
                <p><strong>Definition:</strong> Composition is a stronger form of aggregation where the part's lifecycle is dependent on the whole. It represents a "strong" whole-part relationship where the part cannot exist independently of the whole.</p>
                <h3>Key Points:</h3>
                <ul>
                    <li><strong>Strong Relationship:</strong> The lifecycle of the composed objects is tightly bound to the lifecycle of the composite object.</li>
                    <li><strong>Ownership:</strong> The composite class has complete control over the part class, and when the composite is destroyed, the parts are also destroyed.</li>
                </ul>
                <h3>Example:</h3>
                <p><strong>Use Case:</strong></p>
                <ul>
                    <li><strong>Strong Whole-Part Relationship:</strong> A Car contains an Engine, and the Engine's lifecycle is tied to the Car. When the Car is destroyed, the Engine is also destroyed as it cannot exist independently.</li>
                </ul>

                <h4>Summary</h4>
                <ul>
                    <li><strong>Association:</strong> Represents a general relationship between classes. Example: A Student can be associated with a Course.</li>
                    <li><strong>Aggregation:</strong> A "whole-part" relationship with weak ownership where the part can exist independently. Example: A Department contains multiple Teacher objects.</li>
                    <li><strong>Composition:</strong> A strong "whole-part" relationship where the part's lifecycle is dependent on the whole. Example: A Car contains an Engine that cannot exist independently of the Car.</li>
                </ul>

                <h4>10. Method Overloading</h4>
                <p><strong>Definition:</strong> Method Overloading occurs when multiple methods in a class have the same name but different parameters (type, number, or both). Overloaded methods can perform similar or related tasks, but they differ in the details of their parameter lists.</p>
                <h3>Properties:</h3>
                <ol>
                    <li><strong>Same Method Name:</strong> Methods share the same name but differ in parameter lists.</li>
                    <li><strong>Different Parameters:</strong> Methods must have different parameter types, numbers, or both. Return type alone is not sufficient.</li>
                    <li><strong>Compile-Time Polymorphism:</strong> Overloading is resolved at compile-time based on the method signature.</li>
                </ol>
                <h3>Example:</h3>
                <p><strong>Use Case:</strong></p>
                <ul>
                    <li><strong>Flexibility:</strong> Allows methods to perform similar functions but with different types or numbers of arguments, improving code readability and reusability.</li>
                    <li><strong>Example:</strong> A class that calculates the area of different shapes may have overloaded methods for different shapes and dimensions (e.g., circle, rectangle).</li>
                </ul>

                <h4>11. Method Overriding</h4>
                <p><strong>Definition:</strong> Method Overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. The overridden method in the subclass has the same name, return type, and parameters as the method in the superclass.</p>
                <h3>Properties:</h3>
                <ol>
                    <li><strong>Same Method Signature:</strong> Method name, return type, and parameters must be the same in both superclass and subclass.</li>
                    <li><strong>Run-Time Polymorphism:</strong> Overriding is resolved at run-time based on the actual object type, not the reference type.</li>
                    <li><strong>@Override Annotation:</strong> Optional but recommended for clarity and to prevent errors.</li>
                </ol>
                <h3>Is it possible to overload methods that differ only by their return type in Java?</h3>
                <p>In Java, we cannot overload methods just by changing their return type. The methods must differ by their parameters for overloading to be valid.</p>
                <h3>What is dynamic method dispatch in Java?</h3>
                <p>Dynamic method dispatch is a way Java decides which method to use at runtime when methods are overridden in subclasses. It ensures the correct method is used based on the type of object.</p>
                <h3>Example:</h3>
                <p><strong>Use Case:</strong></p>
                <ul>
                    <li><strong>Specialization:</strong> Allows subclasses to provide specific implementations for methods that are defined in their superclasses, enabling more specialized behavior.</li>
                    <li><strong>Example:</strong> A base class Animal with a generic <span class="method">sound()</span> method can be extended by subclasses like <span class="class">Dog</span> and <span class="class">Cat</span> to provide specific sounds.</li>
                </ul>
                <h4>12. Differences between Method Overloading vs Method Overriding</h4>
                <img src="../../scripts/images/Java/movsmo1.png">
                <img src="../../scripts/images/Java/movsmo2.png">
                <h1><a name="string">3. String and Immutable Interview Questions</a></h1>

                <h4>1. What are the different ways to create string objects?</h4>
                <p>String objects can be created in two ways:</p>
                <ol>
                    <li>Using the <code>'new'</code> operator.</li>
                    <li>Using double-quotes.</li>
                </ol>
                <p>Several constructors are also available in the <span class="class">String</span> class to create
                    strings from a char array, byte array, <span class="class">StringBuilder</span>, and <span
                            class="class">StringBuffer</span>.</p>
                <div>
                    <code>
                        String <span class="variable">S</span> = new <span class="class">String</span>(<span
                            class="variable">"coding ninjas"</span>); // using new operator.<br>
                        String <span class="variable">S</span> = <span class="variable">"coding ninjas"</span>; // using
                        double quotes.
                    </code>
                </div>
                <p>When the String is created with the double quotes, JVM searches it for in the string pool; if the
                    same value is found, it returns the reference to that String else creates a new object with the new
                    value provided.</p>
                <p>In the other case, if the String is created with the <code>'new'</code> operator, then JVM creates a
                    new object but not in the string pool. If we want to create the object in the string pool, we can
                    use the <span class="method">intern()</span> method.</p>

                <h4>2. Why is string made immutable in JAVA?</h4>
                <p>Immutable means unmodifiable or unchangeable. Security is the major reason why strings in Java are
                    made to be immutable. Strings in Java can be used to access data sources like files, databases, or
                    even objects found across networks. Even sometimes, strings store passwords and usernames, which
                    can't be modified once created.</p>

                <h4>3. What is the difference between String, StringBuilder, and StringBuffer in Java?</h4>
                <ul>
                    <li><strong>String:</strong> Immutable, meaning once created, its value cannot be changed. Every
                        modification results in the creation of a new String object. It’s suitable for situations where
                        string values do not change frequently.
                    </li>
                    <li><strong>StringBuilder:</strong> Mutable, meaning its value can be changed after it’s created.
                        It’s designed for scenarios where the string is modified frequently, such as in loops. It is not
                        thread-safe.
                    </li>
                    <li><strong>StringBuffer:</strong> Also mutable and similar to <span
                            class="class">StringBuilder</span>, but it is synchronized, making it thread-safe. Use <span
                            class="class">StringBuffer</span> when working with strings in a multi-threaded environment.
                    </li>
                </ul>

                <h4>4. How do you compare two strings in Java?</h4>
                <ul>
                    <li><span class="method">equals(Object obj)</span>: Compares the content of two strings for
                        equality.
                    </li>
                    <li><span class="method">compareTo(String anotherString)</span>: Compares two strings
                        lexicographically.
                    </li>
                </ul>
                <div>
                    <code>
                        String <span class="variable">s1</span> = <span class="variable">"Hello"</span>;<br>
                        String <span class="variable">s2</span> = <span class="variable">"Hello"</span>;<br>
                        String <span class="variable">s3</span> = <span class="variable">"World"</span>;<br>
                        <span class="class">System</span>.<span class="method">out.println</span>(<span
                            class="variable">s1</span>.<span class="method">equals</span>(<span
                            class="variable">s2</span>)); // true<br>
                        <span class="class">System</span>.<span class="method">out.println</span>(<span
                            class="variable">s1</span>.<span class="method">equals</span>(<span
                            class="variable">s3</span>)); // false<br>
                        <span class="class">System</span>.<span class="method">out.println</span>(<span
                            class="variable">s1</span>.<span class="method">compareTo</span>(<span
                            class="variable">s2</span>)); // 0<br>
                        <span class="class">System</span>.<span class="method">out.println</span>(<span
                            class="variable">s1</span>.<span class="method">compareTo</span>(<span
                            class="variable">s3</span>)); // Negative value (s1 &lt; s3)
                    </code>
                </div>

                <h4>5. What is the result of "abc" + 1 + 2 and why?</h4>
                <p>The result is <span class="variable">"abc12"</span>. In Java, string concatenation is performed from
                    left to right. When a string is concatenated with a number, the number is converted to a string, and
                    then concatenation occurs.</p>

                <h4>6. What is the purpose of the <span class="method">String.intern()</span> method?</h4>
                <p>The <span class="method">intern()</span> method returns a canonical representation of the string
                    object. If a string is already present in the string pool, it returns the reference from the pool;
                    otherwise, it adds the string to the pool and returns its reference.</p>

                <h4>7. How does Java handle string immutability and what are the benefits?</h4>
                <p>In Java, strings are immutable. This means that once a String object is created, its value cannot be
                    changed. Any modification results in a new String object.</p>
                <p>Benefits:</p>
                <ul>
                    <li><strong>Thread Safety:</strong> Immutable objects are inherently thread-safe because their state
                        cannot change.
                    </li>
                    <li><strong>Hashcode Caching:</strong> The <span class="class">String</span> class caches the
                        hashcode, which improves performance for hash-based collections like <span
                                class="class">HashMap</span>.
                    </li>
                    <li><strong>Security:</strong> Immutable objects are safer to use in concurrent environments and are
                        less susceptible to bugs related to object state changes.
                    </li>
                </ul>

                <h4>8. How do you find the length of a string in Java?</h4>
                <p>You can find the length of a string using the <span class="method">length()</span> method of the
                    <span class="class">String</span> class.</p>

                <h4>9. How do you reverse a string in Java?</h4>
                <p>You can reverse a string using <span class="class">StringBuilder</span> or <span class="class">StringBuffer</span>'s
                    <span class="method">reverse()</span> method.</p>

                <h4>10. What is the difference between <span class="method">String.trim()</span> and <span
                        class="method">String.strip()</span>?</h4>
                <ul>
                    <li><span class="method">trim()</span>: Removes leading and trailing whitespace characters (space,
                        tab, etc.) from a string.
                    </li>
                    <li><span class="method">strip()</span>: Introduced in Java 11, it removes leading and trailing
                        whitespace characters according to Unicode definitions.
                    </li>
                </ul>

                <h4>11. What are <span class="method">String.split()</span> and its uses?</h4>
                <p>The <span class="method">split(String regex)</span> method divides a string into an array of
                    substrings based on the specified regular expression delimiter.</p>

                <h4>12. How do you check if a string contains a substring?</h4>
                <p>You can use the <span class="method">contains(CharSequence sequence)</span> method to check if a
                    string contains a specific substring.</p>

                <h4>13. How do you replace characters or substrings in a string?</h4>
                <p>You can use the <span class="method">replace(CharSequence target, CharSequence replacement)</span>
                    method to replace characters or substrings.</p>

                <h4>14. How do you convert a string to uppercase or lowercase?</h4>
                <p>You can use <span class="method">toUpperCase()</span> and <span class="method">toLowerCase()</span>
                    methods to convert a string to uppercase or lowercase.</p>

                <h4>15. How can you check if a string is empty or null?</h4>
                <p>You can use <span class="method">isEmpty()</span> method to check if a string is empty and <code>==
                    null</code> to check if a string is null.</p>

                <h4>16. What is the <span class="method">String.format()</span> method used for?</h4>
                <p>The <span class="method">String.format()</span> method is used to create formatted strings using
                    placeholders.</p>

                <h4>17. How do you remove all non-alphanumeric characters from a string?</h4>
                <p>You can use <span class="method">replaceAll(String regex, String replacement)</span> with a regular
                    expression to remove non-alphanumeric characters.</p>

                <h4>18. Explain String pool in Java.</h4>
                <p>String Pool, also known as SCP (String Constant Pool), is a special storage space in Java heap memory
                    that is used to store unique string objects. Whenever a string object is created, it first checks
                    whether the String object with the same string value is already present in the String pool or not,
                    and if it is available, then the reference to the string object from the string pool is returned.
                    Otherwise, the new string object is added to the string pool, and the respective reference will be
                    returned.</p>

                <h4>19. Why char array is preferred over a String in storing passwords?</h4>
                <p>There are various reasons why a char array rather than a string should be used to store passwords.
                    The following are a few of them:</p>
                <ul>
                    <li><strong>Strings are immutable:</strong> The content of Strings cannot be modified/overwritten
                        because any modification will result in the creation of a new String. As a result, we should
                        always save sensitive data like passwords, Social Security numbers, and so on in a <span
                                class="class">char[]</span> array rather than a String.
                    </li>
                    <li><strong>Security:</strong> Because String is immutable, storing the password as plain text keeps
                        it in memory until it is cleaned up by the garbage collector. As string uses SCP (String
                        Constant Pool) for re-usability of a string, it's possible that it'll remain in memory for a
                        long time, and anyone with access to the SCP or memory dump can simply identify or retrieve the
                        password in plain text. That's another reason why we should use an encrypted password instead of
                        plain text.
                    </li>
                    <li><strong>Logfile safety:</strong> With an array, the data can be erased or wiped up, overwritten
                        and the password will not be present anywhere in the system. Whereas, when using plain String,
                        the chances of mistakenly printing the password to monitors, logs, or other insecure locations
                        are substantially higher.
                    </li>
                </ul>

                <h4>20. Is String thread-safe in Java?</h4>
                <p>Strings are immutable objects, which means they can't be changed or altered once they've been
                    created. As a result, whenever we manipulate a <span class="class">String</span> object, it creates
                    a new String rather than modifying the original string object. In Java, every immutable object is
                    thread-safe, which means String is also thread-safe. As a result, multiple threads can access a
                    string. For instance, if a thread modifies the value of a string, instead of modifying the existing
                    one, a new <span class="class">String</span> is created, and therefore, the original string object
                    that was shared among the threads remains unchanged.</p>

                <h4>21. Why is a string used as a HashMap key in Java?</h4>
                <p>Basically, the <span class="class">HashMap</span> object can store key-value pairs. When creating a
                    <span class="class">HashMap</span> object and storing a key-value pair in that object, you will
                    notice that while storing, the hash code of the key will be calculated, and its calculated value
                    will be placed as the resultant hash code of the key. Now, when the key is passed to fetch its
                    value, then the hash code of the key is calculated again, and if it's equal to the value of the hash
                    code initially calculated, the initial value placed as the resultant hash code of the key is
                    retrieved or fetched.</p>
                <p>Let's say we utilized a variable as a key to store data and then changed the value of that variable.
                    In this case, since we have altered the key, the hash code calculated of the current key will not
                    match the hash code at which its value was originally stored. This makes retrieval impossible.
                    String values are immutable, so once they've been created, they can't be changed. As a result, it is
                    recommended to use Strings as <span class="class">HashMap</span> keys.</p>

                <h4>22. What is the difference between <span class="method">equals()</span> method and <code>==</code>
                    operator?</h4>
                <p>The <span class="method">equals()</span> method matches content of the strings whereas
                    <code>==</code> operator matches object or reference of the strings.</p>

                <h4>23. Steps to Create an Immutable Class</h4>
                <ol>
                    <li><strong>Declare the Class as final:</strong>
                        <ul>
                            <li>This prevents subclasses from inheriting from the class and potentially modifying its
                                behavior.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Make All Fields private and final:</strong>
                        <ul>
                            <li><code>private</code> ensures that the fields cannot be accessed directly from outside
                                the class.
                            </li>
                            <li><code>final</code> ensures that the fields cannot be modified once initialized.</li>
                        </ul>
                    </li>
                    <li><strong>Provide Only Getter Methods:</strong>
                        <ul>
                            <li>Provide public getter methods to access the values of the fields, but do not provide
                                setter methods.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Initialize All Fields in the Constructor:</strong>
                        <ul>
                            <li>Ensure that all fields are initialized through the constructor, and the constructor does
                                not allow modification of the fields after initialization.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Ensure Deep Copies for Mutable Objects:</strong>
                        <ul>
                            <li>If the class contains fields that refer to mutable objects (like arrays or collections),
                                return copies of these objects in the getter methods to prevent external modification.
                            </li>
                        </ul>
                    </li>
                </ol>

                <h4>24. Example of an Immutable Class</h4>
                <div>
                    <code>
                        public final class <span class="class">ImmutableClass</span> {<br>
                        &nbsp;&nbsp;private final <span class="class">int</span> <span
                            class="variable">value</span>;<br>
                        <br>
                        &nbsp;&nbsp;public <span class="class">ImmutableClass</span>(<span class="class">int</span>
                        <span class="variable">value</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;this.<span class="variable">value</span> = <span
                            class="variable">value</span>;<br>
                        &nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;public <span class="class">int</span> <span class="method">getValue</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;return <span class="variable">value</span>;<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>
                <h1><a name="exception">4. Exception Handling Interview Questions</a></p></h1>
                <h4>1. What is the difference between <span class="method">throw</span> and <span
                        class="method">throws</span> in Java?</h4>
                <p><strong>Explanation:</strong></p>
                <ul>
                    <li><span class="method">throw</span>: Used to explicitly throw an exception from a method or any
                        block of code.
                    </li>
                    <li><span class="method">throws</span>: Used in a method signature to declare that the method might
                        throw certain exceptions, signaling the caller of the method that it needs to handle these
                        exceptions.
                    </li>
                </ul>
                <p><strong>Sample Answer:</strong></p>
                <ul>
                    <li><span class="method">throw</span> is used within the body of a method to actually throw an
                        exception:
                    </li>
                    <div>
                        <code>
                            public void <span class="method">doSomething</span>() {<br>
                            &nbsp;&nbsp;if (<span class="variable">someCondition</span>) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">throw</span> new <span class="class">IllegalArgumentException</span>(<span
                                class="variable">"Invalid argument"</span>);<br>
                            &nbsp;&nbsp;}<br>
                            }
                        </code>
                    </div>
                    <li><span class="method">throws</span> is used in the method signature to indicate that a method
                        might throw one or more exceptions:
                    </li>
                    <div>
                        <code>
                            public void <span class="method">readFile</span>(<span class="class">String</span> <span
                                class="variable">filePath</span>) <span class="method">throws</span> <span
                                class="class">IOException</span> {<br>
                            &nbsp;&nbsp;<span class="class">FileReader</span> <span class="variable">file</span> = new
                            <span class="class">FileReader</span>(<span class="variable">filePath</span>);<br>
                            &nbsp;&nbsp;// ... read file<br>
                            }
                        </code>
                    </div>
                </ul>

                <h4>2. What is a <span class="class">finally</span> block and when is it executed?</h4>
                <p><strong>Explanation:</strong> The <span class="class">finally</span> block is used to execute code
                    that must run regardless of whether an exception is thrown or not. It is typically used for cleanup
                    operations like closing files or releasing resources.</p>
                <p><strong>Sample Answer:</strong> The <span class="class">finally</span> block is executed after the
                    try and catch blocks, regardless of whether an exception was thrown or caught. It ensures that
                    important cleanup code runs even if an exception occurs.</p>
                <div>
                    <code>
                        public void <span class="method">readFile</span>(<span class="class">String</span> <span
                            class="variable">filePath</span>) {<br>
                        &nbsp;&nbsp;<span class="class">FileReader</span> <span class="variable">file</span> = null;<br>
                        &nbsp;&nbsp;try {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">file</span> = new <span
                            class="class">FileReader</span>(<span class="variable">filePath</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;// ... read file<br>
                        &nbsp;&nbsp;} catch (<span class="class">IOException</span> <span class="variable">e</span>)
                        {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">System.out.println</span>(<span class="variable">"File not found."</span>);<br>
                        &nbsp;&nbsp;} <span class="class">finally</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;if (<span class="variable">file</span> != null) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">file</span>.<span
                            class="method">close</span>();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (<span class="class">IOException</span> <span
                            class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span
                            class="method">System.out.println</span>(<span
                            class="variable">"Failed to close file."</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>

                <h4>3. Can you have multiple <span class="class">catch</span> blocks for a single try block?</h4>
                <p><strong>Explanation:</strong> Yes, you can have multiple <span class="class">catch</span> blocks to
                    handle different types of exceptions that may be thrown by a try block.</p>
                <p><strong>Sample Answer:</strong> You can have multiple <span class="class">catch</span> blocks for a
                    single try block to handle different exceptions:</p>
                <div>
                    <code>
                        public void <span class="method">processFile</span>(<span class="class">String</span> <span
                            class="variable">filePath</span>) {<br>
                        &nbsp;&nbsp;try {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;// code that may throw multiple types of exceptions<br>
                        &nbsp;&nbsp;} <span class="class">catch</span> (<span class="class">FileNotFoundException</span>
                        <span class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">System.out.println</span>(<span class="variable">"File not found."</span>);<br>
                        &nbsp;&nbsp;} <span class="class">catch</span> (<span class="class">IOException</span> <span
                            class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">System.out.println</span>(<span class="variable">"IO error occurred."</span>);<br>
                        &nbsp;&nbsp;} <span class="class">catch</span> (<span class="class">Exception</span> <span
                            class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">System.out.println</span>(<span class="variable">"General exception occurred."</span>);<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>

                <h4>4. What is the difference between checked and unchecked exceptions?</h4>
                <p><strong>Explanation:</strong></p>
                <ul>
                    <li><strong>Checked Exceptions:</strong> Must be either caught or declared in the method signature
                        using <span class="method">throws</span>. They are checked at compile-time. Examples include
                        <span class="class">IOException</span> and <span class="class">SQLException</span>.
                    </li>
                    <li><strong>Unchecked Exceptions:</strong> Do not need to be caught or declared. They are subclasses
                        of <span class="class">RuntimeException</span> and are checked at runtime. Examples include
                        <span class="class">NullPointerException</span> and <span class="class">ArrayIndexOutOfBoundsException</span>.
                    </li>
                </ul>
                <p><strong>Sample Answer:</strong></p>
                <ul>
                    <li><strong>Checked Exceptions</strong> must be handled explicitly either with a try-catch block or
                        by declaring them in the method signature using <span class="method">throws</span>. They
                        represent conditions that a reasonable application should handle.
                    </li>
                    <li><strong>Unchecked Exceptions</strong> (<span class="class">RuntimeException</span>) do not need
                        to be handled explicitly. They typically represent programming errors or unexpected conditions
                        that should be fixed in the code.
                    </li>
                </ul>

                <h4>5. How do you create a custom exception in Java?</h4>
                <p><strong>Explanation:</strong> To create a custom exception, you need to define a new class that
                    extends the <span class="class">Exception</span> class or one of its subclasses (e.g., <span
                            class="class">RuntimeException</span>).</p>
                <p><strong>Sample Answer:</strong> Here’s how you can create a custom exception:</p>
                <div>
                    <code>
                        public class <span class="class">CustomException</span> extends <span
                            class="class">Exception</span> {<br>
                        &nbsp;&nbsp;public <span class="class">CustomException</span>(<span class="class">String</span>
                        <span class="variable">message</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;super(<span class="variable">message</span>);<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>
                <p><strong>Usage:</strong></p>
                <div>
                    <code>
                        public class <span class="class">TestCustomException</span> {<br>
                        &nbsp;&nbsp;public void <span class="method">validate</span>(<span class="class">int</span>
                        <span class="variable">number</span>) <span class="method">throws</span> <span class="class">CustomException</span>
                        {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;if (<span class="variable">number</span> &lt; 0) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="method">throw</span> new <span class="class">CustomException</span>(<span
                            class="variable">"Number must be non-negative."</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;public static void <span class="method">main</span>(<span
                            class="class">String</span>[] <span class="variable">args</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="class">TestCustomException</span> <span class="variable">test</span>
                        = new <span class="class">TestCustomException</span>();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">test</span>.<span class="method">validate</span>(-1);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="class">catch</span> (<span
                            class="class">CustomException</span> <span class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="method">System.out.println</span>(<span
                            class="variable">e.getMessage()</span>);<br>
                        &nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>

                <h4>6. What is the purpose of <span class="class">try-with-resources</span> statement?</h4>
                <p><strong>Explanation:</strong> The <span class="class">try-with-resources</span> statement is used to
                    automatically close resources such as files or database connections. Resources must implement the
                    <span class="class">AutoCloseable</span> interface or <span class="class">java.io.Closeable</span>.
                </p>
                <p><strong>Sample Answer:</strong> The <span class="class">try-with-resources</span> statement
                    simplifies the management of resources by automatically closing them at the end of the try block,
                    reducing boilerplate code and handling exceptions during resource closure.</p>
                <div>
                    <code>
                        public void <span class="method">readFile</span>(<span class="class">String</span> <span
                            class="variable">filePath</span>) {<br>
                        &nbsp;&nbsp;try (<span class="class">FileReader</span> <span class="variable">file</span> = new
                        <span class="class">FileReader</span>(<span class="variable">filePath</span>)) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;// Read file<br>
                        &nbsp;&nbsp;} <span class="class">catch</span> (<span class="class">IOException</span> <span
                            class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">System.out.println</span>(<span class="variable">"Error reading file."</span>);<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>

                <h4>7. How does exception chaining work in Java?</h4>
                <p><strong>Explanation:</strong> Exception chaining allows you to wrap one exception within another.
                    This is useful for adding context to an exception or preserving the original exception.</p>
                <p><strong>Sample Answer:</strong> Exception chaining involves passing a cause exception to the
                    constructor of a new exception. This allows the new exception to preserve the original exception’s
                    stack trace and message.</p>
                <div>
                    <code>
                        public class <span class="class">ExceptionChainingExample</span> {<br>
                        &nbsp;&nbsp;public void <span class="method">process</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Code that throws an exception<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="class">catch</span> (<span
                            class="class">IOException</span> <span class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="method">throw</span> new <span class="class">CustomException</span>(<span
                            class="variable">"Custom message"</span>, <span class="variable">e</span>); // Chaining<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;}<br>
                        }<br>
                        <br>
                        class <span class="class">CustomException</span> extends <span class="class">Exception</span>
                        {<br>
                        &nbsp;&nbsp;public <span class="class">CustomException</span>(<span class="class">String</span>
                        <span class="variable">message</span>, <span class="class">Throwable</span> <span
                            class="variable">cause</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;super(<span class="variable">message</span>, <span class="variable">cause</span>);<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>

                <h4>8. What is the <span class="class">Throwable</span> class and how does it relate to exceptions and
                    errors?</h4>
                <p><strong>Explanation:</strong> <span class="class">Throwable</span> is the superclass of all errors
                    and exceptions in Java. It has two main subclasses: <span class="class">Exception</span> and <span
                            class="class">Error</span>.</p>
                <p><strong>Sample Answer:</strong> <span class="class">Throwable</span> is the root class for all errors
                    and exceptions. It has two main subclasses:</p>
                <ul>
                    <li><span class="class">Exception</span>: Represents exceptional conditions that a program should
                        catch and handle.
                    </li>
                    <li><span class="class">Error</span>: Represents serious problems that are usually not meant to be
                        caught by applications.
                    </li>
                </ul>
                <div>
                    <code>
                        try {<br>
                        &nbsp;&nbsp;<span class="method">throw</span> new <span
                            class="class">RuntimeException</span>(<span
                            class="variable">"Example Exception"</span>);<br>
                        } <span class="class">catch</span> (<span class="class">Throwable</span> <span class="variable">t</span>)
                        {<br>
                        &nbsp;&nbsp;<span class="method">System.out.println</span>(<span
                            class="variable">t.getMessage()</span>);<br>
                        }<br>
                    </code>
                </div>

                <h4>9. Can you re-throw an exception in Java? How?</h4>
                <p><strong>Explanation:</strong> Yes, you can re-throw an exception in Java. This can be done by simply
                    using the <span class="method">throw</span> keyword again within a catch block.</p>
                <p><strong>Sample Answer:</strong> You can re-throw an exception to propagate it further up the call
                    stack. Here’s how you can do it:</p>
                <div>
                    <code>
                        public void <span class="method">process</span>() <span class="method">throws</span> <span
                            class="class">IOException</span> {<br>
                        &nbsp;&nbsp;try {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;// Code that may throw an <span class="class">IOException</span><br>
                        &nbsp;&nbsp;} <span class="class">catch</span> (<span class="class">IOException</span> <span
                            class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;// Add custom handling if needed<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">throw</span> <span class="variable">e</span>; //
                        Re-throwing the exception<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>

                <h4>10. What happens if an exception is not caught?</h4>
                <p><strong>Explanation:</strong> If an exception is not caught, it propagates up the call stack. If it
                    reaches the top of the call stack without being handled, the Java runtime will handle it, which
                    typically results in the termination of the application.</p>
                <p><strong>Sample Answer:</strong> If an exception is not caught, it propagates up the stack to the
                    previous method calls. If it remains uncaught by any catch blocks, it eventually reaches the Java
                    runtime, which handles it by printing the stack trace and terminating the program.</p>
                <div>
                    <code>
                        public class <span class="class">UncaughtExceptionExample</span> {<br>
                        &nbsp;&nbsp;public static void <span class="method">main</span>(<span
                            class="class">String</span>[] <span class="variable">args</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">method1</span>();<br>
                        &nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;public static void <span class="method">method1</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">method2</span>();<br>
                        &nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;public static void <span class="method">method2</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="method">throw</span> new <span class="class">RuntimeException</span>(<span
                            class="variable">"Uncaught exception example"</span>);<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>

                <h4>11. ClassNotFoundException and NoClassDefFoundError?</h4>
                <h3>ClassNotFoundException</h3>
                <p><strong>Definition:</strong> <span class="class">ClassNotFoundException</span> is a checked exception
                    that occurs when the Java Virtual Machine (JVM) or a <span class="class">ClassLoader</span> tries to
                    load a class by its name, but the class cannot be found in the classpath.</p>
                <p><strong>When It Occurs:</strong></p>
                <ul>
                    <li>When you attempt to load a class using methods like <span class="method">Class.forName</span>(),
                        <span class="method">ClassLoader.loadClass</span>(), or <span class="method">Thread.currentThread().getContextClassLoader().loadClass</span>(),
                        and the class cannot be found.
                    </li>
                    <li>This can happen if the class file is missing from the classpath or if the class name is
                        incorrect.
                    </li>
                </ul>
                <p><strong>Example:</strong></p>
                <div>
                    <code>
                        public class <span class="class">ClassNotFoundExample</span> {<br>
                        &nbsp;&nbsp;public static void <span class="method">main</span>(<span
                            class="class">String</span>[] <span class="variable">args</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Attempt to load a class by name<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="method">Class.forName</span>(<span
                            class="variable">"com.example.NonExistentClass"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="class">catch</span> (<span class="class">ClassNotFoundException</span>
                        <span class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="method">System.out.println</span>(<span
                            class="variable">"Class not found: " + e.getMessage()</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>
                <h3>NoClassDefFoundError</h3>
                <p><strong>Definition:</strong> <span class="class">NoClassDefFoundError</span> is an error that occurs
                    when the JVM attempts to load a class at runtime, but the definition of the class was not found.
                    This usually happens when the class was available at compile time but is missing at runtime.</p>
                <p><strong>When It Occurs:</strong></p>
                <ul>
                    <li>When a class is compiled successfully but cannot be found when the program is run. This could be
                        due to missing class files in the classpath or issues related to class loading.
                    </li>
                    <li>This can also occur if there was a problem during the initialization of the class, which
                        prevented it from being fully loaded.
                    </li>
                </ul>
                <p><strong>Example:</strong></p>
                <div>
                    <code>
                        public class <span class="class">NoClassDefFoundExample</span> {<br>
                        &nbsp;&nbsp;public static void <span class="method">main</span>(<span
                            class="class">String</span>[] <span class="variable">args</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;// Assuming the class `SomeClass` was present during compile-time but
                        missing at runtime<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="class">SomeClass</span> <span class="variable">obj</span> =
                        new <span class="class">SomeClass</span>();<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>
                <h4>12. How would you handle multiple exceptions in a single catch block?</h4>
                <p>Use a single catch block for multiple exceptions by separating them with a pipe (|), e.g., <span
                        class="class">catch</span> (<span class="class">IOException</span> | <span class="class">SQLException</span>
                    <span class="variable">e</span>), to handle both exceptions with the same logic.</p>
                <h4>13. Can we write multiple finally blocks in Java?</h4>
                <p>No, each try can only have one finally block. Multiple finally blocks are not allowed within a single
                    try-catch-finally structure.</p>
                <h4>14. Can you tell me a condition where the finally block will not be executed?</h4>
                <p>The finally block will not execute if the JVM exits via <span class="method">System.exit()</span>
                    during try or catch execution.</p>
                <h4>15. What happens if a return statement is executed inside the try or catch block? Does the finally
                    block still execute?</h4>
                <p>The finally block executes even if a return statement is used in the try or catch block, ensuring
                    cleanup runs.</p>
                <h4>16. Is it possible to execute a program without a catch block? If so, how would you use try and
                    finally together?</h4>
                <p>Yes, we can use try with finally without a catch block to ensure cleanup occurs even if we allow the
                    exception to propagate up.</p>
                <h4>17. Difference between <span class="class">final</span>, <span class="class">finally</span>, and
                    <span class="class">finalize</span></h4>
                <table>
                    <thead>
                    <tr>
                        <th>Key</th>
                        <th>final</th>
                        <th>finally</th>
                        <th>finalize</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><strong>Definition</strong></td>
                        <td>final is the keyword and access modifier which is used to apply restrictions on a class,
                            method, or variable.
                        </td>
                        <td>finally is the block in Java Exception Handling to execute the important code whether the
                            exception occurs or not.
                        </td>
                        <td>finalize is the method in Java which is used to perform clean-up processing just before the
                            object is garbage collected.
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Applicable to</strong></td>
                        <td>final keyword is used with the classes, methods, and variables.</td>
                        <td>finally block is always related to the try and catch block in exception handling.</td>
                        <td>finalize() method is used with the objects.</td>
                    </tr>
                    <tr>
                        <td><strong>Functionality</strong></td>
                        <td>(1) Once declared, final variable becomes constant and cannot be modified.<br>
                            (2) final method cannot be overridden by subclass.<br>
                            (3) final class cannot be inherited.
                        </td>
                        <td>finally block executes code after try and catch blocks regardless of whether an exception
                            occurs or not.
                        </td>
                        <td>Used to perform clean-up operations before an object is reclaimed by the garbage
                            collector.
                        </td>
                    </tr>
                    </tbody>
                </table>
                <h4>18. What are <span class="class">StackOverflowError</span> and <span
                        class="class">OutOfMemoryError</span>?</h4>
                <h3>StackOverflowError</h3>
                <p><strong>Definition:</strong> <span class="class">StackOverflowError</span> is an error that occurs
                    when a program’s stack space is exhausted, usually due to excessive recursion.</p>
                <p><strong>Example:</strong></p>
                <div>
                    <code>
                        public class <span class="class">StackOverflowExample</span> {<br>
                        &nbsp;&nbsp;public static void <span class="method">recursiveMethod</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;recursiveMethod(); // Infinite recursion<br>
                        &nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;public static void <span class="method">main</span>(<span
                            class="class">String</span>[] <span class="variable">args</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;recursiveMethod();<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>
                <h3>OutOfMemoryError</h3>
                <p><strong>Definition:</strong> <span class="class">OutOfMemoryError</span> is an error that occurs when
                    the JVM runs out of memory and cannot allocate more objects.</p>
                <p><strong>Example:</strong></p>
                <div>
                    <code>
                        public class <span class="class">OutOfMemoryExample</span> {<br>
                        &nbsp;&nbsp;public static void <span class="method">main</span>(<span
                            class="class">String</span>[] <span class="variable">args</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;List&lt;<span class="class">String</span>&gt; <span class="variable">list</span>
                        = new ArrayList<>();<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;while (true) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">list.add</span>(new <span
                            class="class">String</span>(<span class="variable">"Out of memory!"</span>));<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>

                <h4>19. How would you handle exceptions in a multi-threaded environment?</h4>
                <p><strong>Explanation:</strong> In a multi-threaded environment, exceptions are handled similarly to
                    single-threaded programs, but you should consider that exceptions in one thread do not affect other
                    threads. It's important to catch and handle exceptions within each thread separately, and you can
                    use thread-specific mechanisms (like <span class="class">Thread.setUncaughtExceptionHandler</span>)
                    to handle uncaught exceptions.</p>
                <p><strong>Sample Answer:</strong> In a multi-threaded environment, handle exceptions in each thread
                    separately using try-catch blocks. For uncaught exceptions, you can set an uncaught exception
                    handler for threads using <span class="method">Thread.setUncaughtExceptionHandler</span>. This
                    allows you to manage or log exceptions that occur in any thread.</p>
                <div>
                    <code>
                        public class <span class="class">ThreadExceptionExample</span> {<br>
                        &nbsp;&nbsp;public static void <span class="method">main</span>(<span
                            class="class">String</span>[] <span class="variable">args</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Thread.<span class="method">setDefaultUncaughtExceptionHandler</span>(new
                        <span class="class">Thread.UncaughtExceptionHandler</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="method">public void</span> <span
                            class="method">uncaughtException</span>(<span class="class">Thread</span> <span
                            class="variable">t</span>, <span class="class">Throwable</span> <span
                            class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span
                            class="method">System.out.println</span>(<span class="variable">"Uncaught exception: " + e.getMessage()</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;});<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Runnable <span class="variable">task</span> = () -> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="method">throw</span> new <span class="class">RuntimeException</span>(<span
                            class="variable">"Exception in thread"</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;};<br>
                        <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Thread <span class="variable">thread</span> = new <span class="class">Thread</span>(<span
                            class="variable">task</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">thread.start()</span>;<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>

                <h4>20. What is the difference between <span class="class">throw</span> and <span
                        class="class">throws</span>?</h4>
                <p><strong>Definition:</strong></p>
                <ul>
                    <li><span class="class">throw</span>: Used to explicitly throw an exception from a method or block
                        of code.
                    </li>
                    <li><span class="class">throws</span>: Used in a method signature to declare that a method can throw
                        certain exceptions, making it the responsibility of the calling code to handle them.
                    </li>
                </ul>
                <p><strong>Example:</strong></p>
                <div>
                    <code>
                        public class <span class="class">ThrowVsThrowsExample</span> {<br>
                        &nbsp;&nbsp;public void <span class="method">method1</span>() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;throw new <span class="class">RuntimeException</span>(<span
                            class="variable">"Explicit exception"</span>);<br>
                        &nbsp;&nbsp;}<br>
                        <br>
                        &nbsp;&nbsp;public void <span class="method">method2</span>() <span class="method">throws</span>
                        <span class="class">IOException</span> {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;throw new <span class="class">IOException</span>(<span class="variable">"IO exception"</span>);<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>

                <h4>21. How would you use exception handling to validate user input?</h4>
                <p><strong>Explanation:</strong> Exception handling can be used to validate user input by catching and
                    handling exceptions that arise from invalid input. This helps in providing feedback to users and
                    ensuring that the application can handle erroneous input gracefully.</p>
                <p><strong>Sample Answer:</strong> To validate user input, use try-catch blocks to catch exceptions from
                    parsing or processing user input. For example, catching <span
                            class="class">NumberFormatException</span> when converting a string to a number allows you
                    to provide meaningful error messages to the user.</p>
                <div>
                    <code>
                        public class <span class="class">UserInputValidation</span> {<br>
                        &nbsp;&nbsp;public void <span class="method">validateInput</span>(<span
                            class="class">String</span> <span class="variable">input</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <span class="variable">number</span> = Integer.parseInt(<span
                            class="variable">input</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="method">System.out.println</span>(<span
                            class="variable">"Valid number: " + <span class="variable">number</span></span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;} <span class="class">catch</span> (<span class="class">NumberFormatException</span>
                        <span class="variable">e</span>) {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="method">System.out.println</span>(<span
                            class="variable">"Invalid input. Please enter a valid number."</span>);<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        &nbsp;&nbsp;}<br>
                        }
                    </code>
                </div>
                <h1><a name="syncronization">7. Synchronization Interview Questions</a></h1>
                <h4>1. What is synchronization in Java, and why is it important?</h4>
                <p><strong>Explanation:</strong> Synchronization is a mechanism to control access to shared resources in
                    a multi-threaded environment to prevent issues such as data inconsistency and race conditions. It
                    ensures that only one thread can access a critical section of code or a shared resource at a time.
                </p>
                <p><strong>Sample Answer:</strong> Synchronization in Java ensures that only one thread can access a
                    critical section of code or modify shared resources at any given time. It is crucial for maintaining
                    data consistency and preventing issues like race conditions, where multiple threads might
                    simultaneously change shared data, leading to unpredictable behavior.</p>

                <h4>2. Explain the difference between <span class="class">synchronized method</span> and <span
                        class="class">synchronized block</span>.</h4>
                <p><strong>Explanation:</strong></p>
                <ul>
                    <li><span class="class">Synchronized Method:</span> Synchronizes the entire method, ensuring that
                        only one thread can execute any synchronized instance method of the class at a time.
                    </li>
                    <li><span class="class">Synchronized Block:</span> Allows for more granular control by synchronizing
                        only a specific block of code within a method, which can improve performance by reducing the
                        scope of synchronization.
                    </li>
                </ul>
                <p><strong>Sample Answer:</strong> A synchronized method ensures that only one thread can execute the
                    method on an instance of the class at a time. This is suitable for scenarios where the entire method
                    needs to be protected. On the other hand, a synchronized block allows for finer control by
                    synchronizing only a specific section of code, which can help reduce contention and improve
                    performance when only part of the method needs synchronization.</p>

                <h4>3. What is the difference between <span class="class">synchronized instance methods</span> and <span
                        class="class">synchronized static methods</span>?</h4>
                <p><strong>Explanation:</strong></p>
                <ul>
                    <li><span class="class">Synchronized Instance Methods:</span> Synchronize on the instance level,
                        meaning each instance of the class has its own lock.
                    </li>
                    <li><span class="class">Synchronized Static Methods:</span> Synchronize on the class level, meaning
                        there is a single lock for all instances of the class.
                    </li>
                </ul>
                <p><strong>Sample Answer:</strong> A synchronized instance method locks on the instance of the class, so
                    each object has its own lock. Conversely, a synchronized static method locks on the <span
                            class="class">Class</span> object representing the class, meaning that the lock is shared
                    among all instances of the class. Thus, synchronized static methods can control access to
                    class-level data shared by all instances.</p>

                <h4>4. What is a deadlock, and how can you avoid it in Java?</h4>
                <p><strong>Explanation:</strong> Deadlock occurs when two or more threads are waiting for each other to
                    release resources, causing a standstill where none of the threads can proceed. It typically happens
                    when multiple locks are acquired in different orders by different threads.</p>
                <p><strong>Sample Answer:</strong> Deadlock is a situation where two or more threads are blocked
                    forever, waiting for each other to release resources. To avoid deadlock, you should:</p>
                <ol>
                    <li>Avoid Nested Locks: Minimize the use of multiple locks.</li>
                    <li>Lock Ordering: Always acquire locks in a consistent global order.</li>
                    <li>Timeouts: Use <span class="class">tryLock</span> with timeout to avoid waiting indefinitely.
                    </li>
                </ol>

                <h4>5. What is a <span class="class">ReentrantLock</span>, and how does it differ from the <span
                        class="class">synchronized</span> keyword?</h4>
                <p><strong>Explanation:</strong> <span class="class">ReentrantLock</span> is a class from the <span
                        class="class">java.util.concurrent.locks</span> package that provides advanced locking
                    capabilities compared to the <span class="class">synchronized</span> keyword. It offers features
                    like <span class="method">tryLock</span>, timed lock, and the ability to interrupt a thread while
                    waiting for a lock.</p>
                <p><strong>Sample Answer:</strong> <span class="class">ReentrantLock</span> is a more flexible locking
                    mechanism compared to the <span class="class">synchronized</span> keyword. It allows for features
                    such as <span class="method">tryLock</span> (which attempts to acquire the lock without blocking),
                    timed lock (which can wait for a specific period), and the ability to interrupt threads waiting for
                    the lock. In contrast, <span class="class">synchronized</span> provides a simpler but less flexible
                    locking mechanism that automatically releases the lock when the block or method execution is
                    complete.</p>

                <h4>6. How does the <span class="class">volatile</span> keyword differ from synchronization?</h4>
                <p><strong>Explanation:</strong> The <span class="class">volatile</span> keyword ensures that changes to
                    a variable are visible to all threads immediately. However, it does not provide mutual exclusion
                    like synchronization, meaning it does not prevent multiple threads from simultaneously accessing or
                    modifying the variable.</p>
                <p><strong>Sample Answer:</strong> The <span class="class">volatile</span> keyword guarantees visibility
                    of changes to a variable across threads, ensuring that when one thread updates the variable, other
                    threads see the updated value immediately. However, <span class="class">volatile</span> does not
                    provide mutual exclusion, so it cannot prevent multiple threads from concurrently modifying the
                    variable. For mutual exclusion and thread safety, synchronization or other concurrency mechanisms
                    should be used.</p>

                <h4>7. What is the <span class="class">wait</span> and <span class="class">notify</span> mechanism in
                    Java, and how does it work?</h4>
                <p><strong>Explanation:</strong> The <span class="class">wait</span> and <span
                        class="class">notify</span> methods are used for inter-thread communication. <span
                        class="class">wait</span> causes the current thread to wait until another thread invokes <span
                        class="method">notify</span> or <span class="method">notifyAll</span> on the same object.</p>
                <p><strong>Sample Answer:</strong> The <span class="class">wait</span> and <span
                        class="class">notify</span> methods are used for inter-thread communication. When a thread calls
                    <span class="method">wait</span> on an object, it releases the lock and waits until another thread
                    calls <span class="method">notify</span> or <span class="method">notifyAll</span> on the same
                    object. <span class="method">notify</span> wakes up one waiting thread, while <span class="method">notifyAll</span>
                    wakes up all waiting threads. These methods must be called from a synchronized block or method.</p>

                <h4>8. Explain the concept of the "Monitor" in Java.</h4>
                <p><strong>Explanation:</strong> In Java, a monitor is an internal mechanism used by the Java Virtual
                    Machine (JVM) to control access to synchronized methods and blocks. Each object has an associated
                    monitor, and a thread must acquire the monitor before executing synchronized code.</p>
                <p><strong>Sample Answer:</strong> In Java, a monitor is a synchronization construct that controls
                    access to synchronized methods and blocks. Each object has its own monitor, which is used to ensure
                    that only one thread can execute synchronized code on that object at a time. When a thread acquires
                    a monitor, other threads are blocked from entering synchronized sections of code that use the same
                    monitor until the monitor is released.</p>

                <h4>9. What is the difference between <span class="class">notify</span> and <span class="class">notifyAll</span>?
                </h4>
                <p><strong>Explanation:</strong></p>
                <ul>
                    <li><span class="class">notify</span>: Wakes up a single thread that is waiting on the object's
                        monitor.
                    </li>
                    <li><span class="class">notifyAll</span>: Wakes up all threads waiting on the object's monitor.</li>
                </ul>
                <p><strong>Sample Answer:</strong> The <span class="class">notify</span> method wakes up a single thread
                    waiting on the object's monitor, whereas <span class="class">notifyAll</span> wakes up all threads
                    waiting on the object's monitor. <span class="class">notify</span> is typically used when you have a
                    single waiting thread, while <span class="class">notifyAll</span> is used when multiple threads
                    might be waiting for different conditions.</p>

                <h4>10. Can you explain a real-world scenario where synchronization is necessary?</h4>
                <p><strong>Explanation:</strong> Synchronization is necessary in scenarios where multiple threads access
                    and modify shared resources, such as in a banking application where multiple threads may perform
                    transactions on the same account.</p>
                <p><strong>Sample Answer:</strong> Consider a banking application where multiple threads are processing
                    transactions on the same bank account. Without synchronization, concurrent deposits and withdrawals
                    could lead to incorrect account balances due to race conditions. Synchronization ensures that only
                    one thread can perform a transaction at a time, maintaining the integrity of the account balance.
                </p>

                <h4>11. Object-Level Lock vs Class-Level Lock?</h4>
                <p><strong>Object-level locks</strong> are associated with instances of a class. When you synchronize a
                    block of code or a method on an instance of a class, you are using an object-level lock.</p>
                <ul>
                    <li><span class="variable">Lock Scope:</span> The lock applies to a specific instance of the class.
                        Different instances of the same class have different locks.
                    </li>
                    <li><span class="variable">Usage:</span> You synchronize methods or blocks on the instance (using
                        <span class="method">synchronized(this)</span>).
                    </li>
                </ul>
                <p><strong>Class-level locks</strong> are associated with the class itself, rather than individual
                    instances. When you synchronize a block of code or a method on a class object, you are using a
                    class-level lock.</p>
                <ul>
                    <li><span class="variable">Lock Scope:</span> The lock applies to the class object, meaning that all
                        instances of the class share the same lock.
                    </li>
                    <li><span class="variable">Usage:</span> You synchronize static methods or blocks on the class
                        object (using <span class="method">synchronized(ClassName.class)</span>).
                    </li>
                </ul>
                <h4><a name="serialization">8. Serialization And DeSerialization Interview Questions</a></p></h4>
                <h3>1. Custom Serialization:</h3>
                <ul>
                    <li>Implement <span class="method">writeObject</span> and <span class="method">readObject</span>
                        methods in your class to control the serialization process.
                    </li>
                    <li>Useful for handling complex objects or excluding sensitive information.</li>
                </ul>
                <p><strong>Example:</strong></p>
                <div class="code">
                    <span class="keyword">class</span> <span class="class">Person</span> <span class="keyword">implements</span>
                    <span class="class">Serializable</span> {
                    <span class="keyword">private static final long</span> <span
                        class="variable">serialVersionUID</span> <span class="keyword">=</span> <span
                        class="number">1L</span>;
                    <span class="keyword">private</span> <span class="class">String</span> <span
                        class="variable">name</span>;
                    <span class="keyword">private transient int</span> <span class="variable">age</span>; <span
                        class="comment">// `transient` fields are not serialized</span>

                    <span class="keyword">public</span> <span class="class">Person</span>(<span
                        class="class">String</span> <span class="variable">name</span>, <span class="class">int</span>
                    <span class="variable">age</span>) {
                    <span class="keyword">this</span>.<span class="variable">name</span> <span class="keyword">=</span>
                    <span class="variable">name</span>;
                    <span class="keyword">this</span>.<span class="variable">age</span> <span class="keyword">=</span>
                    <span class="variable">age</span>;
                    }

                    <span class="keyword">private void</span> <span class="method">writeObject</span>(<span
                        class="class">ObjectOutputStream</span> <span class="variable">oos</span>) <span
                        class="keyword">throws</span> <span class="class">IOException</span> {
                    <span class="variable">oos</span>.<span class="method">defaultWriteObject</span>(); <span
                        class="comment">// Serialize default fields</span>
                    <span class="variable">oos</span>.<span class="method">writeInt</span>(<span
                        class="variable">age</span>); <span
                        class="comment">// Manually serialize the transient field</span>
                    }

                    <span class="keyword">private void</span> <span class="method">readObject</span>(<span
                        class="class">ObjectInputStream</span> <span class="variable">ois</span>) <span class="keyword">throws</span>
                    <span class="class">IOException</span>, <span class="class">ClassNotFoundException</span> {
                    <span class="variable">ois</span>.<span class="method">defaultReadObject</span>(); <span
                        class="comment">// Deserialize default fields</span>
                    <span class="variable">age</span> <span class="keyword">=</span> <span
                        class="variable">ois</span>.<span class="method">readInt</span>(); <span class="comment">// Manually deserialize the transient field</span>
                    }

                    <span class="keyword">@Override</span>
                    <span class="keyword">public</span> <span class="class">String</span> <span
                        class="method">toString</span>() {
                    <span class="keyword">return</span> <span class="string">"Person{name='"</span> <span
                        class="keyword">+</span> <span class="variable">name</span> <span class="keyword">+</span> <span
                        class="string">"', age="</span> <span class="keyword">+</span> <span class="variable">age</span>
                    <span class="keyword">+</span> <span class="string">"}"</span>;
                    }
                    }
                </div>
                <h3>2. Version Control:</h3>
                <ul>
                    <li>Use <span class="variable">serialVersionUID</span> to handle changes in the class definition.
                        The value should be updated if the class structure changes significantly.
                    </li>
                </ul>
                <h3>3. Handling transient Fields:</h3>
                <ul>
                    <li>Fields marked as <span class="keyword">transient</span> are not serialized. Ensure that these
                        fields are handled properly during deserialization, either by initializing them to default
                        values or by custom deserialization logic.
                    </li>
                </ul>
                <h4>2. How do you make a Java class serializable?</h4>
                <p><strong>Explanation:</strong> To make a class serializable, it must implement the <span
                        class="class">java.io.Serializable</span> interface. This interface is a marker interface,
                    meaning it does not contain any methods. It simply indicates that the class is eligible for
                    serialization.</p>
                <p><strong>Sample Answer:</strong> To make a Java class serializable, the class must implement the <span
                        class="class">java.io.Serializable</span> interface. This is a marker interface with no methods.
                    Here’s an example:</p>
                <div class="code">
                    <span class="keyword">import</span> <span class="class">java.io.Serializable</span>;

                    <span class="keyword">public class</span> <span class="class">Person</span> <span class="keyword">implements</span>
                    <span class="class">Serializable</span> {
                    <span class="keyword">private static final long</span> <span
                        class="variable">serialVersionUID</span> <span class="keyword">=</span> <span
                        class="number">1L</span>;
                    <span class="keyword">private</span> <span class="class">String</span> <span
                        class="variable">name</span>;
                    <span class="keyword">private</span> <span class="class">int</span> <span
                        class="variable">age</span>;

                    <span class="comment">// Constructor, getters, and setters</span>
                    }
                </div>
                <h4>3. What is serialVersionUID and why is it important?</h4>
                <p><strong>Explanation:</strong> <span class="variable">serialVersionUID</span> is a unique identifier
                    used during the deserialization process to ensure that a loaded class corresponds to the serialized
                    object. It helps to verify the compatibility of the class.</p>
                <p><strong>Sample Answer:</strong> <span class="variable">serialVersionUID</span> is a unique identifier
                    associated with a serialized class. It is used to ensure that a serialized object matches the class
                    definition during deserialization. If the <span class="variable">serialVersionUID</span> of the
                    class and the serialized object do not match, it indicates that the class definition has changed,
                    and an <span class="class">InvalidClassException</span> may be thrown. It is important to define
                    <span class="variable">serialVersionUID</span> explicitly to avoid version conflicts.</p>
                <h4>4. What is the purpose of the <span class="keyword">transient</span> keyword in serialization?</h4>
                <p><strong>Explanation:</strong> The <span class="keyword">transient</span> keyword is used to mark
                    fields that should not be serialized. Transient fields are excluded from the serialization process.
                </p>
                <p><strong>Sample Answer:</strong> The <span class="keyword">transient</span> keyword is used to
                    indicate that a field should not be serialized. When an object is serialized, fields marked as <span
                            class="keyword">transient</span> are skipped, and their values are not included in the byte
                    stream. This is useful for fields that contain sensitive information or are not needed after
                    deserialization.</p>
                <h4>5. How do you handle custom serialization and deserialization?</h4>
                <p><strong>Explanation:</strong> Custom serialization and deserialization can be handled by implementing
                    <span class="method">writeObject</span> and <span class="method">readObject</span> methods in your
                    class. These methods allow you to define how the object’s state should be serialized and
                    deserialized.</p>
                <p><strong>Sample Answer:</strong> To handle custom serialization and deserialization, you can implement
                    the <span class="method">writeObject</span> and <span class="method">readObject</span> methods in
                    your class. These methods are used to customize the serialization process. Here’s an example:</p>
                <div class="code">
                    <span class="keyword">import</span> <span class="class">java.io.*</span>;

                    <span class="keyword">public class</span> <span class="class">Person</span> <span class="keyword">implements</span>
                    <span class="class">Serializable</span> {
                    <span class="keyword">private static final long</span> <span
                        class="variable">serialVersionUID</span> <span class="keyword">=</span> <span
                        class="number">1L</span>;
                    <span class="keyword">private</span> <span class="class">String</span> <span
                        class="variable">name</span>;
                    <span class="keyword">private transient int</span> <span class="variable">age</span>; <span
                        class="comment">// Transient field</span>

                    <span class="comment">// Constructor, getters, and setters</span>

                    <span class="keyword">private void</span> <span class="method">writeObject</span>(<span
                        class="class">ObjectOutputStream</span> <span class="variable">oos</span>) <span
                        class="keyword">throws</span> <span class="class">IOException</span> {
                    <span class="variable">oos</span>.<span class="method">defaultWriteObject</span>(); <span
                        class="comment">// Serialize default fields</span>
                    <span class="variable">oos</span>.<span class="method">writeInt</span>(<span
                        class="variable">age</span>); <span class="comment">// Manually serialize transient field</span>
                    }

                    <span class="keyword">private void</span> <span class="method">readObject</span>(<span
                        class="class">ObjectInputStream</span> <span class="variable">ois</span>) <span class="keyword">throws</span>
                    <span class="class">IOException</span>, <span class="class">ClassNotFoundException</span> {
                    <span class="variable">ois</span>.<span class="method">defaultReadObject</span>(); <span
                        class="comment">// Deserialize default fields</span>
                    <span class="variable">age</span> <span class="keyword">=</span> <span
                        class="variable">ois</span>.<span class="method">readInt</span>(); <span class="comment">// Manually deserialize transient field</span>
                    }
                    }
                </div>
                <h4>6. What is the difference between <span class="method">writeObject</span> and <span class="method">readObject</span>
                    methods in custom serialization?</h4>
                <p><strong>Explanation:</strong> <span class="method">writeObject</span> is used to serialize an
                    object’s state, and <span class="method">readObject</span> is used to deserialize the object’s
                    state. These methods allow for custom control over how the object is serialized and deserialized.
                </p>
                <p><strong>Sample Answer:</strong> The <span class="method">writeObject</span> method is used to
                    serialize the state of an object by writing it to an <span class="class">ObjectOutputStream</span>.
                    The <span class="method">readObject</span> method is used to deserialize the object by reading its
                    state from an <span class="class">ObjectInputStream</span>. These methods allow for custom
                    serialization logic, such as handling transient fields or adding additional data.</p>
                <h4>7. What are some common issues encountered with serialization and how can they be resolved?</h4>
                <p><strong>Explanation:</strong> Common issues with serialization include versioning problems, handling
                    transient fields, and compatibility issues. These can be resolved by using <span class="variable">serialVersionUID</span>,
                    properly managing transient fields, and implementing custom serialization methods.</p>
                <p><strong>Sample Answer:</strong> Common issues with serialization include:</p>
                <ul>
                    <li><span class="variable">Versioning Problems:</span> Different versions of a class may cause <span
                            class="class">InvalidClassException</span>. To resolve this, define a <span
                            class="variable">serialVersionUID</span> explicitly to manage version compatibility.
                    </li>
                    <li><span class="variable">Transient Fields:</span> Fields marked as <span
                            class="keyword">transient</span> are not serialized. Ensure that these fields are properly
                        handled during deserialization by initializing them or using custom serialization methods.
                    </li>
                    <li><span class="variable">Class Compatibility:</span> Ensure that the class definition has not
                        changed in a way that makes it incompatible with the serialized data.
                    </li>
                </ul>
                <h4>8. How do you serialize and deserialize objects to and from a file?</h4>
                <p><strong>Explanation:</strong> To serialize an object to a file, use <span class="class">ObjectOutputStream</span>
                    to write the object to a file. To deserialize, use <span class="class">ObjectInputStream</span> to
                    read the object from the file.</p>
                <p><strong>Sample Answer:</strong> To serialize an object to a file:</p>
                <div class="code">
                    <span class="keyword">import</span> <span class="class">java.io.*</span>;

                    <span class="keyword">public class</span> <span class="class">SerializationToFileExample</span> {
                    <span class="keyword">public static void</span> <span class="method">main</span>(<span
                        class="class">String[]</span> <span class="variable">args</span>) {
                    <span class="class">Person</span> <span class="variable">person</span> <span
                        class="keyword">=</span> <span class="keyword">new</span> <span
                        class="class">Person</span>(<span class="string">"Alice"</span>, <span class="number">30</span>);
                    <span class="keyword">try</span> (<span class="class">ObjectOutputStream</span> <span
                        class="variable">out</span> <span class="keyword">=</span> <span class="keyword">new</span>
                    <span class="class">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="class">FileOutputStream</span>(<span
                        class="string">"person.ser"</span>))) {
                    <span class="variable">out</span>.<span class="method">writeObject</span>(<span class="variable">person</span>);
                    } <span class="keyword">catch</span> (<span class="class">IOException</span> <span class="variable">e</span>)
                    {
                    <span class="variable">e</span>.<span class="method">printStackTrace</span>();
                    }
                    }
                    }
                </div>
                <p>To deserialize the object from the file:</p>
                <div class="code">
                    <span class="keyword">import</span> <span class="class">java.io.*</span>;

                    <span class="keyword">public class</span> <span class="class">DeserializationFromFileExample</span>
                    {
                    <span class="keyword">public static void</span> <span class="method">main</span>(<span
                        class="class">String[]</span> <span class="variable">args</span>) {
                    <span class="keyword">try</span> (<span class="class">ObjectInputStream</span> <span
                        class="variable">in</span> <span class="keyword">=</span> <span class="keyword">new</span> <span
                        class="class">ObjectInputStream</span>(<span class="keyword">new</span> <span class="class">FileInputStream</span>(<span
                        class="string">"person.ser"</span>))) {
                    <span class="class">Person</span> <span class="variable">person</span> <span
                        class="keyword">=</span> (<span class="class">Person</span>) <span
                        class="variable">in</span>.<span class="method">readObject</span>();
                    <span class="keyword">System.out.println</span>(<span class="variable">person</span>);
                    } <span class="keyword">catch</span> (<span class="class">IOException</span> <span class="variable">e</span>
                    | <span class="class">ClassNotFoundException</span> <span class="variable">e</span>) {
                    <span class="variable">e</span>.<span class="method">printStackTrace</span>();
                    }
                    }
                    }
                </div>
                <h4>9. What is an InvalidClassException and how can it be avoided?</h4>
                <p><strong>Explanation:</strong> <span class="class">InvalidClassException</span> is thrown when the
                    serialized object cannot be deserialized due to a mismatch between the class definitions. This
                    usually happens when the class definition has changed since the object was serialized.</p>
                <p><strong>Sample Answer:</strong> <span class="class">InvalidClassException</span> is thrown when there
                    is a mismatch between the <span class="variable">serialVersionUID</span> of the class during
                    serialization and deserialization, or when the class definition has changed in a way that is not
                    compatible with the serialized object. To avoid this exception:</p>
                <ul>
                    <li>Define a <span class="variable">serialVersionUID</span> explicitly to control version
                        compatibility.
                    </li>
                    <li>Avoid changing the class definition in a way that affects serialization.</li>
                </ul>
                <h4>10. Can you serialize objects of classes that do not implement Serializable?</h4>
                <p><strong>Explanation:</strong> No, objects of classes that do not implement the <span class="class">Serializable</span>
                    interface cannot be serialized. Attempting to serialize such objects will result in a <span
                            class="class">java.io.NotSerializableException</span>.</p>
                <p><strong>Sample Answer:</strong> No, you cannot serialize objects of classes that do not implement the
                    <span class="class">Serializable</span> interface. Attempting to serialize such objects will result
                    in a <span class="class">java.io.NotSerializableException</span>. To make a class serializable, it
                    must implement the <span class="class">Serializable</span> interface.</p>
                <h1><a name="sortings">6. Java Comparable vs Comparator Interview Questions</a></p></h1>

                <h4>1. What is the difference between Comparable and Comparator in Java?</h4>
                <p><strong>Explanation:</strong></p>
                <ul>
                    <li><span class="variable">Comparable</span>: Allows an object to be compared to another object of
                        the same type. It is used to define the natural ordering of objects.
                    </li>
                    <li><span class="variable">Comparator</span>: Allows for custom ordering of objects. It is used to
                        define multiple sorting orders or when objects cannot be compared naturally.
                    </li>
                </ul>
                <p><strong>Sample Answer:</strong> <span class="variable">Comparable</span> is used to define the
                    natural ordering of objects of a class by implementing the <span class="method">compareTo</span>
                    method within the class itself. This allows objects of the class to be sorted automatically using
                    methods like <span class="method">Collections.sort</span> or <span class="method">Arrays.sort</span>.
                    On the other hand, <span class="variable">Comparator</span> is used to define custom ordering of
                    objects by implementing the <span class="method">compare</span> method in a separate class or as an
                    anonymous class. This allows for different sorting orders and is useful when you need multiple ways
                    to sort objects.</p>

                <h4>2. How does the <span class="method">compareTo</span> method in the <span class="variable">Comparable</span>
                    interface work?</h4>
                <p><strong>Explanation:</strong> The <span class="method">compareTo</span> method defines the natural
                    ordering of objects by returning an integer value:</p>
                <ul>
                    <li>A negative integer if the current object is less than the other object.</li>
                    <li>Zero if the current object is equal to the other object.</li>
                    <li>A positive integer if the current object is greater than the other object.</li>
                </ul>
                <p><strong>Sample Answer:</strong> The <span class="method">compareTo</span> method is used to define
                    the natural ordering of objects. It returns:</p>
                <ul>
                    <li>A negative integer if the current object is less than the specified object.</li>
                    <li>Zero if the current object is equal to the specified object.</li>
                    <li>A positive integer if the current object is greater than the specified object.</li>
                </ul>
                <p>Here’s an example of how <span class="method">compareTo</span> might be implemented in a <span
                        class="class">Person</span> class:</p>
                <div class="code">
                    <span class="keyword">public class</span> <span class="class">Person</span> <span class="keyword">implements</span>
                    <span class="class">Comparable&lt;Person&gt;</span> {
                    <span class="keyword">private</span> <span class="class">String</span> <span
                        class="variable">name</span>;
                    <span class="keyword">private</span> <span class="class">int</span> <span
                        class="variable">age</span>;

                    <span class="keyword">public</span> <span class="class">Person</span>(<span
                        class="class">String</span> <span class="variable">name</span>, <span class="class">int</span>
                    <span class="variable">age</span>) {
                    <span class="variable">this.name</span> <span class="keyword">=</span> <span
                        class="variable">name</span>;
                    <span class="variable">this.age</span> <span class="keyword">=</span> <span
                        class="variable">age</span>;
                    }

                    <span class="keyword">@Override</span>
                    <span class="keyword">public int</span> <span class="method">compareTo</span>(<span class="class">Person</span>
                    <span class="variable">other</span>) {
                    <span class="keyword">return</span> <span class="class">Integer</span>.<span
                        class="method">compare</span>(<span class="variable">this.age</span>, <span class="variable">other.age</span>);
                    <span class="comment">// Sort by age</span>
                    }

                    <span class="comment">// Getters, setters, and toString() methods</span>
                    }
                </div>

                <h4>3. How do you use <span class="variable">Comparator</span> to sort a list of objects in different
                    ways?</h4>
                <p><strong>Explanation:</strong> <span class="variable">Comparator</span> can be used to define multiple
                    sorting criteria for a list of objects. You can create different implementations of <span
                            class="variable">Comparator</span> for different sorting orders.</p>
                <p><strong>Sample Answer:</strong> To sort a list of objects using <span
                        class="variable">Comparator</span>, you can create different <span
                        class="variable">Comparator</span> implementations. For example, you might have a <span
                        class="class">Person</span> class with fields like name and age. You can define comparators to
                    sort by name or by age.</p>
                <p>Here’s an example:</p>
                <div class="code">
                    <span class="keyword">import</span> <span class="class">java.util.*</span>;

                    <span class="keyword">public class</span> <span class="class">Person</span> {
                    <span class="keyword">private</span> <span class="class">String</span> <span
                        class="variable">name</span>;
                    <span class="keyword">private</span> <span class="class">int</span> <span
                        class="variable">age</span>;

                    <span class="comment">// Constructor, getters, and toString() methods</span>

                    <span class="keyword">public static void</span> <span class="method">main</span>(<span
                        class="class">String[]</span> <span class="variable">args</span>) {
                    <span class="class">List&lt;Person&gt;</span> <span class="variable">people</span> <span
                        class="keyword">=</span> <span class="class">Arrays.asList</span>(
                    <span class="keyword">new</span> <span class="class">Person</span>(<span
                        class="string">"Alice"</span>, <span class="number">30</span>),
                    <span class="keyword">new</span> <span class="class">Person</span>(<span class="string">"Bob"</span>,
                    <span class="number">25</span>),
                    <span class="keyword">new</span> <span class="class">Person</span>(<span
                        class="string">"Charlie"</span>, <span class="number">35</span>)
                    );

                    <span class="comment">// Sort by age</span>
                    <span class="class">Comparator&lt;Person&gt;</span> <span class="variable">ageComparator</span>
                    <span class="keyword">=</span> <span class="class">Comparator</span>.<span class="method">comparingInt</span>(<span
                        class="class">Person::getAge</span>);
                    <span class="class">Collections</span>.<span class="method">sort</span>(<span class="variable">people</span>,
                    <span class="variable">ageComparator</span>);

                    <span class="comment">// Sort by name</span>
                    <span class="class">Comparator&lt;Person&gt;</span> <span class="variable">nameComparator</span>
                    <span class="keyword">=</span> <span class="class">Comparator</span>.<span
                        class="method">comparing</span>(<span class="class">Person::getName</span>);
                    <span class="class">Collections</span>.<span class="method">sort</span>(<span class="variable">people</span>,
                    <span class="variable">nameComparator</span>);
                    }
                    }
                </div>

                <h4>4. What are the advantages of using <span class="variable">Comparator</span> over <span
                        class="variable">Comparable</span>?</h4>
                <p><strong>Explanation:</strong></p>
                <ul>
                    <li><span class="variable">Flexibility</span>: <span class="variable">Comparator</span> allows for
                        multiple sorting criteria and can be used independently of the class being compared.
                    </li>
                    <li><span class="variable">Non-intrusive</span>: <span class="variable">Comparator</span> does not
                        require modifying the class being compared, allowing you to sort objects that you do not
                        control.
                    </li>
                </ul>
                <p><strong>Sample Answer:</strong> Using <span class="variable">Comparator</span> offers greater
                    flexibility compared to <span class="variable">Comparable</span> because it allows you to define
                    multiple sorting orders and does not require changes to the class being sorted. You can create
                    various <span class="variable">Comparator</span> implementations for different sorting criteria, and
                    you can use them independently of the class definition.</p>

                <h4>5. Can you provide an example of a custom <span class="variable">Comparator</span> for sorting
                    objects?</h4>
                <p><strong>Explanation:</strong> A custom <span class="variable">Comparator</span> can be used to define
                    sorting logic based on specific criteria that differ from the natural ordering.</p>
                <p><strong>Sample Answer:</strong> Here’s an example of a custom <span
                        class="variable">Comparator</span> to sort a list of <span class="class">Person</span> objects
                    by age in descending order:</p>
                <div class="code">
                    <span class="keyword">import</span> <span class="class">java.util.*</span>;

                    <span class="keyword">public class</span> <span class="class">Person</span> {
                    <span class="keyword">private</span> <span class="class">String</span> <span
                        class="variable">name</span>;
                    <span class="keyword">private</span> <span class="class">int</span> <span
                        class="variable">age</span>;

                    <span class="comment">// Constructor, getters, and toString() methods</span>

                    <span class="keyword">public static void</span> <span class="method">main</span>(<span
                        class="class">String[]</span> <span class="variable">args</span>) {
                    <span class="class">List&lt;Person&gt;</span> <span class="variable">people</span> <span
                        class="keyword">=</span> <span class="class">Arrays.asList</span>(
                    <span class="keyword">new</span> <span class="class">Person</span>(<span
                        class="string">"Alice"</span>, <span class="number">30</span>),
                    <span class="keyword">new</span> <span class="class">Person</span>(<span class="string">"Bob"</span>,
                    <span class="number">25</span>),
                    <span class="keyword">new</span> <span class="class">Person</span>(<span
                        class="string">"Charlie"</span>, <span class="number">35</span>)
                    );

                    <span class="comment">// Custom comparator to sort by age in descending order</span>
                    <span class="class">Comparator&lt;Person&gt;</span> <span
                        class="variable">ageDescendingComparator</span> <span class="keyword">=</span> (<span
                        class="class">p1</span>, <span class="class">p2</span>) -> <span
                        class="class">Integer</span>.<span class="method">compare</span>(<span class="variable">p2.getAge()</span>,
                    <span class="variable">p1.getAge()</span>);
                    <span class="class">Collections</span>.<span class="method">sort</span>(<span class="variable">people</span>,
                    <span class="variable">ageDescendingComparator</span>);

                    <span class="class">System.out</span>.<span class="method">println</span>(<span class="variable">people</span>);
                    }
                    }
                </div>

                <h4>6. How do you handle null values when using <span class="variable">Comparator</span>?</h4>
                <p><strong>Explanation:</strong> Java 8 introduced <span class="variable">Comparator.nullsFirst</span>
                    and <span class="variable">Comparator.nullsLast</span> methods to handle null values in a way that
                    you can specify whether null values should come before or after non-null values in sorting.</p>
                <p><strong>Sample Answer:</strong> To handle null values using <span class="variable">Comparator</span>,
                    you can use <span class="variable">Comparator.nullsFirst</span> or <span class="variable">Comparator.nullsLast</span>.
                    For example, to ensure that null values come last when sorting:</p>
                <div class="code">
                    <span class="class">Comparator&lt;Person&gt;</span> <span class="variable">nullSafeComparator</span>
                    <span class="keyword">=</span> <span class="class">Comparator</span>.<span
                        class="method">comparing</span>(<span class="class">Person::getName</span>, <span class="class">Comparator.nullsLast</span>(<span
                        class="class">Comparator.naturalOrder</span>()));
                </div>

                <h4>7. What is the use of <span class="variable">Comparator.thenComparing</span>?</h4>
                <p><strong>Explanation:</strong> <span class="variable">Comparator.thenComparing</span> allows for
                    chaining multiple comparators to perform secondary sorting when the primary sorting criteria are
                    equal.</p>
                <p><strong>Sample Answer:</strong> <span class="variable">Comparator.thenComparing</span> is used to
                    chain multiple comparators together. It allows you to define a primary sorting order and a secondary
                    sorting order for tie-breaking. For example, to sort <span class="class">Person</span> objects first
                    by age and then by name:</p>
                <div class="code">
                    <span class="class">Comparator&lt;Person&gt;</span> <span
                        class="variable">ageThenNameComparator</span> <span class="keyword">=</span> <span
                        class="class">Comparator</span>.<span class="method">comparing</span>(<span class="class">Person::getAge</span>)
                    .<span class="method">thenComparing</span>(<span class="class">Person::getName</span>);
                </div>

                <h4>8. How do you compare objects using <span class="variable">Comparator</span> in a case-insensitive
                    manner?</h4>
                <p><strong>Explanation:</strong> To compare strings in a case-insensitive manner using <span
                        class="variable">Comparator</span>, you can use <span class="class">String.CASE_INSENSITIVE_ORDER</span>
                    or create a custom comparator.</p>
                <p><strong>Sample Answer:</strong> You can use <span class="class">String.CASE_INSENSITIVE_ORDER</span>
                    for case-insensitive comparisons of strings:</p>
                <div class="code">
                    <span class="class">Comparator&lt;String&gt;</span> <span
                        class="variable">caseInsensitiveComparator</span> <span class="keyword">=</span> <span
                        class="class">String.CASE_INSENSITIVE_ORDER</span>;
                </div>
                <p>Alternatively, you can create a custom comparator:</p>
                <div class="code">
                    <span class="class">Comparator&lt;String&gt;</span> <span class="variable">customCaseInsensitiveComparator</span>
                    <span class="keyword">=</span> (<span class="class">s1</span>, <span class="class">s2</span>) ->
                    <span class="variable">s1.compareToIgnoreCase</span>(<span class="variable">s2</span>);
                </div>

                <h4>9. Comparison of <span class="variable">Comparable</span> and <span
                        class="variable">Comparator</span></h4>
                <table>
                    <thead>
                    <tr>
                        <th>Feature</th>
                        <th><span class="variable">Comparable</span></th>
                        <th><span class="variable">Comparator</span></th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>Definition</td>
                        <td><span class="variable">Comparable</span> is an interface that defines a natural ordering of
                            objects of a class.
                        </td>
                        <td><span class="variable">Comparator</span> is an interface that defines custom ordering of
                            objects.
                        </td>
                    </tr>
                    <tr>
                        <td>Method</td>
                        <td><span class="method">compareTo</span> method must be implemented.</td>
                        <td><span class="method">compare</span> method must be implemented.</td>
                    </tr>
                    <tr>
                        <td>Implementation</td>
                        <td>Implemented within the class whose objects are being compared.</td>
                        <td>Implemented in a separate class or as an anonymous class.</td>
                    </tr>
                    <tr>
                        <td>Flexibility</td>
                        <td>Less flexible, as it only allows for a single natural ordering.</td>
                        <td>More flexible, allowing for multiple sorting orders.</td>
                    </tr>
                    <tr>
                        <td>Intrusiveness</td>
                        <td>Requires modifying the class to implement <span class="method">compareTo</span>.</td>
                        <td>Non-intrusive, does not require modifications to the class.</td>
                    </tr>
                    <tr>
                        <td>Usage</td>
                        <td>Used when a single natural ordering is sufficient.</td>
                        <td>Used when multiple or custom sorting orders are needed.</td>
                    </tr>
                    <tr>
                        <td>Null Handling</td>
                        <td>Does not provide direct support for handling null values.</td>
                        <td>Provides methods like <span class="method">nullsFirst</span> and <span class="method">nullsLast</span>
                            for handling null values.
                        </td>
                    </tr>
                    </tbody>
                </table>
                <h1><a name="multithreading">5. Multithreading Interview Questions</a></p></h1>

                <h4>1. Processes</h4>
                <p>A process is an independent program in execution. It has its own memory space, code, data, and system
                    resources (such as file handles). Processes are managed by the operating system and are isolated
                    from each other, meaning one process cannot directly access another process's memory.</p>

                <h4>2. Multithreading</h4>
                <p>Multithreading refers to the ability of a CPU or a single process to execute multiple threads
                    concurrently. A thread is the smallest unit of execution within a process. Threads within the same
                    process share the same memory space but run independently.</p>

                <h3>Comparison between Process and Thread</h3>
                <table border="1">
                    <tr>
                        <th>Feature</th>
                        <th>Process</th>
                        <th>Thread</th>
                    </tr>
                    <tr>
                        <td>Memory</td>
                        <td>Separate memory space</td>
                        <td>Shared memory space within the same process</td>
                    </tr>
                    <tr>
                        <td>Communication</td>
                        <td>Requires IPC mechanisms like pipes, sockets</td>
                        <td>Easier communication through shared memory</td>
                    </tr>
                    <tr>
                        <td>Creation Cost</td>
                        <td>High (resource-intensive)</td>
                        <td>Low (lightweight)</td>
                    </tr>
                    <tr>
                        <td>Isolation</td>
                        <td>Processes are isolated from each other</td>
                        <td>Threads can interfere with each other if not synchronized</td>
                    </tr>
                    <tr>
                        <td>Failure Impact</td>
                        <td>Failure in one process doesn't affect others</td>
                        <td>Failure in one thread can potentially affect the whole process</td>
                    </tr>
                    <tr>
                        <td>Concurrency</td>
                        <td>Can run multiple processes concurrently</td>
                        <td>Can run multiple threads concurrently within the same process</td>
                    </tr>
                    <tr>
                        <td>Use Cases</td>
                        <td>Running independent programs</td>
                        <td>Performing parallel tasks within the same application</td>
                    </tr>
                </table>

                <p>Multithreading is a powerful feature in Java that allows concurrent execution of two or more threads
                    within a single program. Threads are lightweight subprocesses that share the same memory space but
                    can execute independently.</p>

                <h3>1. Thread</h3>
                <p>A thread is the smallest unit of execution in a process. Multiple threads can run concurrently within
                    a single Java process.</p>

                <h3>2. Multithreading</h3>
                <p>The process of executing multiple threads simultaneously to achieve parallelism. Multithreading helps
                    in utilizing CPU resources more effectively by performing multiple tasks concurrently.</p>

                <h3>3. Concurrency vs. Parallelism:</h3>
                <ul>
                    <li><strong>Concurrency:</strong> Multiple threads are making progress simultaneously.</li>
                    <li><strong>Parallelism:</strong> Multiple threads are executing at the exact same time on
                        multi-core processors.
                    </li>
                </ul>

                <h3>3. Thread Lifecycle</h3>
                <ul>
                    <li><strong>New:</strong> A thread that is created but not yet started.</li>
                    <li><strong>Runnable:</strong> A thread that is ready to run or currently running.</li>
                    <li><strong>Blocked:</strong> A thread that is blocked, waiting for a monitor lock.</li>
                    <li><strong>Waiting:</strong> A thread that is waiting indefinitely for another thread to perform a
                        particular action.
                    </li>
                    <li><strong>Timed Waiting:</strong> A thread that is waiting for another thread to perform a
                        particular action for up to a specified waiting time.
                    </li>
                    <li><strong>Terminated:</strong> A thread that has exited.</li>
                </ul>

                <h3>4. Thread Creation</h3>
                <ul>
                    <li>Extending the <span class="keyword">Thread</span> class:</li>
                    <div class="code">
                        <span class="keyword">public class</span> <span class="class-name">MyThread</span> <span
                            class="keyword">extends</span> <span class="class-name">Thread</span> {
                        <span class="keyword">public void</span> <span class="method-name">run</span>() {
                        <span class="keyword">System.out</span>.println(<span
                            class="variable">"Thread is running..."</span>);
                        }

                        <span class="keyword">public static void</span> <span class="method-name">main</span>(<span
                            class="keyword">String[]</span> <span class="variable">args</span>) {
                        <span class="class-name">MyThread</span> <span class="variable">t1</span> = <span
                            class="keyword">new</span> <span class="class-name">MyThread</span>();
                        <span class="variable">t1</span>.<span class="method-name">start</span>(); <span
                            class="comment">// Start the thread</span>
                        }
                        }
                    </div>
                    <li>Implementing the <span class="keyword">Runnable</span> interface:</li>
                    <div class="code">
                        <span class="keyword">public class</span> <span class="class-name">MyRunnable</span> <span
                            class="keyword">implements</span> <span class="class-name">Runnable</span> {
                        <span class="keyword">public void</span> <span class="method-name">run</span>() {
                        <span class="keyword">System.out</span>.println(<span
                            class="variable">"Thread is running..."</span>);
                        }

                        <span class="keyword">public static void</span> <span class="method-name">main</span>(<span
                            class="keyword">String[]</span> <span class="variable">args</span>) {
                        <span class="keyword">Thread</span> <span class="variable">t1</span> = <span
                            class="keyword">new</span> <span class="keyword">Thread</span>(<span
                            class="keyword">new</span> <span class="class-name">MyRunnable</span>());
                        <span class="variable">t1</span>.<span class="method-name">start</span>(); <span
                            class="comment">// Start the thread</span>
                        }
                        }
                    </div>
                </ul>

                <h3>5. User Thread vs Daemon Thread</h3>
                <p>User Threads: Main application logic, such as processing data, handling user interactions, or
                    managing transactions.</p>
                <p>Daemon Threads: Background services like logging, monitoring system performance, or handling
                    asynchronous events.</p>

                <table border="1">
                    <tr>
                        <th>Feature</th>
                        <th>User Thread</th>
                        <th>Daemon Thread</th>
                    </tr>
                    <tr>
                        <td>Keeps JVM Running</td>
                        <td>Yes, JVM keeps running as long as user threads are active.</td>
                        <td>No, JVM exits when only daemon threads are left running.</td>
                    </tr>
                    <tr>
                        <td>Purpose</td>
                        <td>To perform main application tasks.</td>
                        <td>To perform background tasks that support user threads.</td>
                    </tr>
                    <tr>
                        <td>Default Behavior</td>
                        <td>Created as a user thread by default.</td>
                        <td>Must be explicitly set as a daemon thread using <span
                                class="method-name">setDaemon(true)</span>.
                        </td>
                    </tr>
                    <tr>
                        <td>Termination</td>
                        <td>JVM waits for user threads to finish before terminating.</td>
                        <td>JVM does not wait for daemon threads to finish; they are terminated when all user threads
                            have finished.
                        </td>
                    </tr>
                    <tr>
                        <td>Typical Use Cases</td>
                        <td>Handling user requests, performing computations, etc.</td>
                        <td>Garbage collection, background monitoring, etc.</td>
                    </tr>
                </table>

                <h3>6. start method vs run method</h3>
                <p>The <span class="method-name">start()</span> method is used to begin the execution of a new thread.
                    It internally calls the <span class="method-name">run()</span> method after setting up the necessary
                    infrastructure for the thread.</p>
                <p>The <span class="method-name">run()</span> method contains the code that constitutes the new thread's
                    task. It can be called directly like a normal method, but doing so does not start a new thread.</p>

                <h4>Differences Between start() and run()</h4>
                <table border="1">
                    <tr>
                        <th>Feature</th>
                        <th><span class="method-name">start()</span></th>
                        <th><span class="method-name">run()</span></th>
                    </tr>
                    <tr>
                        <td>Thread Creation</td>
                        <td>Creates a new thread.</td>
                        <td>Does not create a new thread.</td>
                    </tr>
                    <tr>
                        <td>Execution</td>
                        <td>Executes the <span class="method-name">run()</span> method in a separate thread.</td>
                        <td>Executes the <span class="method-name">run()</span> method in the current thread.</td>
                    </tr>
                    <tr>
                        <td>Asynchronous Execution</td>
                        <td>Yes, the <span class="method-name">run()</span> method executes asynchronously.</td>
                        <td>No, the <span class="method-name">run()</span> method executes synchronously.</td>
                    </tr>
                    <tr>
                        <td>Method Call</td>
                        <td>Calls the <span class="method-name">run()</span> method indirectly after setting up the
                            thread.
                        </td>
                        <td>Directly calls the <span class="method-name">run()</span> method like a normal method.</td>
                    </tr>
                    <tr>
                        <td>Thread Lifecycle</td>
                        <td>Transitions the thread from "new" to "runnable".</td>
                        <td>Does not affect the thread lifecycle; no state change.</td>
                    </tr>
                </table>

                <h3>7. wait() and sleep()</h3>
                <p>The <span class="method-name">wait()</span> method is used to make a thread pause its execution and
                    release the lock it holds on an object until another thread calls <span
                            class="method-name">notify()</span> or <span class="method-name">notifyAll()</span> on the
                    same object.</p>

                <h4>Key Points:</h4>
                <ul>
                    <li>Object Method: <span class="method-name">wait()</span> is a method of the <span class="keyword">Object</span>
                        class, not the <span class="keyword">Thread</span> class. It is called on objects, typically
                        within synchronized blocks or methods.
                    </li>
                    <li>Releases Lock: When a thread calls <span class="method-name">wait()</span>, it releases the lock
                        on the object it holds, allowing other threads to acquire the lock and execute synchronized code
                        blocks or methods.
                    </li>
                    <li>Must Be in Synchronized Context: <span class="method-name">wait()</span> can only be called from
                        within a synchronized context, i.e., the block or method where <span
                                class="method-name">wait()</span> is called must be synchronized.
                    </li>
                    <li>Thread State: The thread that calls <span class="method-name">wait()</span> enters the "waiting"
                        state. It will remain in this state until it is notified by another thread using <span
                                class="method-name">notify()</span> or <span class="method-name">notifyAll()</span>, or
                        until it is interrupted.
                    </li>
                    <li>Coordination Between Threads: <span class="method-name">wait()</span> is often used in scenarios
                        where threads need to communicate or coordinate with each other, like a producer-consumer
                        problem.
                    </li>
                </ul>
                <p>The <span class="method-name">sleep()</span> method is used to pause the execution of the current
                    thread for a specified period.</p>

                <h4>Key Points:</h4>
                <ul>
                    <li>Thread Method: <span class="method-name">sleep()</span> is a static method of the <span
                            class="keyword">Thread</span> class, so it always affects the current thread.
                    </li>
                    <li>Does Not Release Lock: Unlike <span class="method-name">wait()</span>, <span
                            class="method-name">sleep()</span> does not release the lock held by the thread. The thread
                        remains in the "blocked" state while sleeping.
                    </li>
                    <li>Not Synchronized: <span class="method-name">sleep()</span> can be called from any context,
                        synchronized or not. It does not involve any synchronization or inter-thread communication.
                    </li>
                    <li>Fixed Duration: <span class="method-name">sleep()</span> pauses the thread for a fixed amount of
                        time specified in milliseconds, and the thread automatically wakes up after this time has
                        passed.
                    </li>
                    <li>Thread State: The thread enters the "timed waiting" state while sleeping. It can be interrupted
                        by another thread while sleeping, in which case it throws an <span class="keyword">InterruptedException</span>.
                    </li>
                </ul>

                <h4>Key Differences</h4>
                <table border="1">
                    <tr>
                        <th>Feature</th>
                        <th><span class="method-name">wait()</span></th>
                        <th><span class="method-name">sleep()</span></th>
                    </tr>
                    <tr>
                        <td>Class</td>
                        <td>Defined in <span class="keyword">Object</span> class.</td>
                        <td>Defined in <span class="keyword">Thread</span> class.</td>
                    </tr>
                    <tr>
                        <td>Purpose</td>
                        <td>Pauses the thread and releases the lock for inter-thread communication.</td>
                        <td>Pauses the thread for a specified time without releasing the lock.</td>
                    </tr>
                    <tr>
                        <td>Lock Release</td>
                        <td>Yes, the lock on the object is released.</td>
                        <td>No, the lock is not released.</td>
                    </tr>
                    <tr>
                        <td>Synchronization Required</td>
                        <td>Yes, must be called within a synchronized block or method.</td>
                        <td>No, can be called from any context.</td>
                    </tr>
                    <tr>
                        <td>Thread State</td>
                        <td>Thread enters "waiting" state.</td>
                        <td>Thread enters "timed waiting" state.</td>
                    </tr>
                    <tr>
                        <td>Wake-Up Mechanism</td>
                        <td>Woken up by <span class="method-name">notify()</span>, <span
                                class="method-name">notifyAll()</span>, or interruption.
                        </td>
                        <td>Automatically resumes after the sleep duration, or if interrupted.</td>
                    </tr>
                    <tr>
                        <td>Use Case</td>
                        <td>Inter-thread communication (e.g., producer-consumer).</td>
                        <td>Temporarily pausing execution (e.g., delays, retries).</td>
                    </tr>
                </table>

                <h3>8. notify() and notifyAll()</h3>
                <h4>Key Differences</h4>
                <table border="1">
                    <tr>
                        <th>Feature</th>
                        <th><span class="method-name">notify()</span></th>
                        <th><span class="method-name">notifyAll()</span></th>
                    </tr>
                    <tr>
                        <td>Number of Threads Notified</td>
                        <td>Notifies one thread (JVM decides which one).</td>
                        <td>Notifies all waiting threads.</td>
                    </tr>
                    <tr>
                        <td>Use Case</td>
                        <td>Use when only one thread needs to proceed.</td>
                        <td>Use when multiple threads may proceed.</td>
                    </tr>
                    <tr>
                        <td>Resource Contention</td>
                        <td>Lower contention since only one thread proceeds.</td>
                        <td>Higher contention as all threads compete for the lock.</td>
                    </tr>
                    <tr>
                        <td>Complexity</td>
                        <td>Simpler, but can lead to missed notifications if not used carefully.</td>
                        <td>More robust, but can lead to more contention and overhead.</td>
                    </tr>
                </table>

                <h3>9. Runnable Interface vs Callable Interface</h3>
                <p><span class="keyword">Runnable</span> is a functional interface that represents a task to be executed
                    by a thread. It has a single method, <span class="method-name">run()</span>, which contains the code
                    to be executed.</p>

                <h4>Key Points:</h4>
                <ul>
                    <li>No Return Value: The <span class="method-name">run()</span> method does not return a result. It
                        has a <span class="keyword">void</span> return type.
                    </li>
                    <li>No Checked Exceptions: The <span class="method-name">run()</span> method cannot throw any
                        checked exceptions (unless they are caught within the method itself).
                    </li>
                    <li>Execution: Typically used when you do not need to return any result after the execution or
                        handle checked exceptions.
                    </li>
                    <li>Usage: <span class="keyword">Runnable</span> is passed to a <span class="keyword">Thread</span>
                        object or an <span class="keyword">ExecutorService</span> to execute the task.
                    </li>
                </ul>

                <h4>Example:</h4>
                <div class="code">
                    <span class="keyword">class</span> MyRunnable implements <span class="keyword">Runnable</span> {
                    <span class="keyword">@Override</span>
                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="method-name">run()</span>
                    {
                    <span class="method-name">System.out.println</span>(<span class="string">"Executing task in Runnable."</span>);
                    }
                    }

                    <span class="keyword">public</span> <span class="keyword">class</span> RunnableExample {
                    <span class="keyword">public static void main</span>(<span class="keyword">String</span>[] <span
                        class="variable-name">args</span>) {
                    <span class="keyword">Thread</span> <span class="variable-name">thread</span> = <span
                        class="keyword">new</span> <span class="keyword">Thread</span>(<span class="keyword">new</span>
                    MyRunnable());
                    <span class="method-name">thread.start</span>();
                    }
                    }
                </div>

                <p><span class="keyword">Callable</span> is a generic functional interface that represents a task that
                    can return a result and throw a checked exception. It has a single method, <span
                            class="method-name">call()</span>, which contains the code to be executed.</p>

                <h4>Key Points:</h4>
                <ul>
                    <li>Return Value: The <span class="method-name">call()</span> method returns a result of a specified
                        type. It is a generic method, so the return type is specified by the type parameter <span
                                class="type">V</span>.
                    </li>
                    <li>Checked Exceptions: The <span class="method-name">call()</span> method can throw checked
                        exceptions, allowing you to handle errors during task execution.
                    </li>
                    <li>Execution: Typically used when you need to return a result after the task completes or handle
                        checked exceptions during execution.
                    </li>
                    <li>Usage: <span class="keyword">Callable</span> is often used with <span class="keyword">ExecutorService</span>
                        to submit tasks that return results, such as through <span class="keyword">Future</span>.
                    </li>
                </ul>

                <h4>Example:</h4>
                <div class="code">
                    <span class="keyword">import</span> <span class="keyword">java.util.concurrent.Callable</span>;
                    <span class="keyword">import</span> <span
                        class="keyword">java.util.concurrent.ExecutorService</span>;
                    <span class="keyword">import</span> <span class="keyword">java.util.concurrent.Executors</span>;
                    <span class="keyword">import</span> <span class="keyword">java.util.concurrent.Future</span>;

                    <span class="keyword">class</span> MyCallable implements <span class="keyword">Callable</span><<span
                        class="type">Integer</span>> {
                    <span class="keyword">@Override</span>
                    <span class="keyword">public</span> <span class="type">Integer</span> <span
                        class="method-name">call</span>() <span class="keyword">throws</span> <span class="keyword">Exception</span>
                    {
                    <span class="method-name">System.out.println</span>(<span class="string">"Executing task in Callable."</span>);
                    <span class="keyword">return</span> <span class="number">42</span>;
                    }
                    }

                    <span class="keyword">public</span> <span class="keyword">class</span> CallableExample {
                    <span class="keyword">public static void main</span>(<span class="keyword">String</span>[] <span
                        class="variable-name">args</span>) <span class="keyword">throws</span> <span class="keyword">Exception</span>
                    {
                    <span class="keyword">ExecutorService</span> <span class="variable-name">executor</span> = <span
                        class="keyword">Executors.newSingleThreadExecutor</span>();
                    MyCallable <span class="variable-name">task</span> = <span class="keyword">new</span> MyCallable();

                    <span class="keyword">Future</span><<span class="type">Integer</span>> <span class="variable-name">future</span>
                    = <span class="variable-name">executor.submit</span>(<span class="variable-name">task</span>);
                    <span class="type">Integer</span> <span class="variable-name">result</span> = <span
                        class="variable-name">future.get</span>(); <span class="comment">// Retrieve the result after execution</span>

                    <span class="method-name">System.out.println</span>(<span
                        class="string">"Result from Callable: "</span> + <span class="variable-name">result</span>);

                    <span class="variable-name">executor.shutdown</span>();
                    }
                    }
                </div>

                <h4>Key Differences Between Runnable and Callable</h4>
                <table border="1">
                    <tr>
                        <th>Feature</th>
                        <th><span class="keyword">Runnable</span></th>
                        <th><span class="keyword">Callable</span></th>
                    </tr>
                    <tr>
                        <td>Return Type</td>
                        <td><span class="keyword">void</span> (no return value)</td>
                        <td>Generic type <span class="type">V</span> (returns a result)</td>
                    </tr>
                    <tr>
                        <td>Method Name</td>
                        <td><span class="method-name">run()</span></td>
                        <td><span class="method-name">call()</span></td>
                    </tr>
                    <tr>
                        <td>Exception Handling</td>
                        <td>Cannot throw checked exceptions (directly)</td>
                        <td>Can throw checked exceptions</td>
                    </tr>
                    <tr>
                        <td>Usage Scenario</td>
                        <td>When you do not need a return value or checked exception handling</td>
                        <td>When you need a return value or checked exception handling</td>
                    </tr>
                    <tr>
                        <td>Execution</td>
                        <td>Can be executed by <span class="keyword">Thread</span> or <span class="keyword">ExecutorService</span>
                        </td>
                        <td>Typically executed by <span class="keyword">ExecutorService</span> and returns <span
                                class="keyword">Future</span><<span class="type">V</span>>
                        </td>
                    </tr>
                    <tr>
                        <td>Concurrency Utilities</td>
                        <td>Often used with <span class="keyword">Thread</span> or <span
                                class="keyword">ExecutorService</span></td>
                        <td>Commonly used with <span class="keyword">ExecutorService</span>, <span class="keyword">Future</span>,
                            and <span class="keyword">ForkJoinPool</span></td>
                    </tr>
                </table>

                <h3>How join() Works</h3>
                <p>When you call <span class="method-name">join()</span> on a thread, the current thread (the one
                    executing the join) enters a waiting state until the specified thread (the one on which <span
                            class="method-name">join()</span> was called) terminates. Once the specified thread
                    completes, the waiting thread resumes its execution.</p>

                <h3>10. Thread communication</h3>
                <h4><span class="method-name">wait()</span> Method</h4>
                <ul>
                    <li>Purpose: The <span class="method-name">wait()</span> method is used to make the current thread
                        release the lock it holds on an object and enter a waiting state until another thread calls
                        <span class="method-name">notify()</span> or <span class="method-name">notifyAll()</span> on the
                        same object.
                    </li>
                    <li>How It Works: When a thread calls <span class="method-name">wait()</span>, it temporarily pauses
                        its execution and releases the lock on the object so other threads can acquire it. The thread
                        remains in a waiting state until it is notified.
                    </li>
                    <li>Key Points:
                        <ul>
                            <li>Must be called from within a synchronized block or method.</li>
                            <li>The thread that calls <span class="method-name">wait()</span> will remain in a waiting
                                state until it is notified by another thread using <span
                                        class="method-name">notify()</span> or <span
                                        class="method-name">notifyAll()</span>.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h4><span class="method-name">notify()</span> Method</h4>
                <ul>
                    <li>Purpose: The <span class="method-name">notify()</span> method wakes up a single thread that is
                        waiting on the object’s monitor. It is called from within a synchronized block or method.
                    </li>
                    <li>How It Works: When <span class="method-name">notify()</span> is called, one of the threads
                        waiting on the object is woken up. If multiple threads are waiting, which thread gets woken up
                        is not specified and is determined by the JVM.
                    </li>
                    <li>Key Points:
                        <ul>
                            <li>Only one waiting thread is notified. If multiple threads are waiting, the choice is
                                non-deterministic.
                            </li>
                            <li>The notified thread must still reacquire the lock on the object before it can proceed.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h4><span class="method-name">notifyAll()</span> Method</h4>
                <ul>
                    <li>Purpose: The <span class="method-name">notifyAll()</span> method wakes up all threads that are
                        waiting on the object’s monitor. It is also called from within a synchronized block or method.
                    </li>
                    <li>How It Works: When <span class="method-name">notifyAll()</span> is called, all waiting threads
                        are woken up. They must all reacquire the lock on the object before proceeding.
                    </li>
                    <li>Key Points:
                        <ul>
                            <li>All waiting threads are notified and must compete to reacquire the lock.</li>
                            <li>Useful when multiple threads need to be informed about a change or condition.</li>
                        </ul>
                    </li>
                </ul>

                <h3>11. Priority of Thread</h3>
                <p>In Java, you can assign priority to threads using the <span class="method-name">setPriority()</span>
                    method of the <span class="keyword">Thread</span> class. Thread priority is used to influence the
                    order in which threads are scheduled for execution by the JVM's thread scheduler.</p>

                <h4>Thread Priority Levels</h4>
                <ul>
                    <li><span class="keyword">Thread.MIN_PRIORITY</span> (value 1)</li>
                    <li><span class="keyword">Thread.NORM_PRIORITY</span> (value 5)</li>
                    <li><span class="keyword">Thread.MAX_PRIORITY</span> (value 10)</li>
                </ul>

                <h4>Key Points</h4>
                <ul>
                    <li>Priority is only a suggestion: The JVM’s thread scheduler may choose to ignore thread priority
                        and manage thread execution based on its own criteria.
                    </li>
                    <li>Priority ranges from 1 to 10. The default priority is 5.</li>
                    <li>Higher priority threads are generally executed before lower priority threads, but this behavior
                        is not guaranteed and can vary by JVM implementation.
                    </li>
                    <li>Thread priorities are used to improve the responsiveness of an application by making sure that
                        high-priority tasks are executed more frequently than low-priority tasks.
                    </li>
                </ul>
                <h3>11. What is Deadlock?</h3>
                <p>A deadlock in a multi-threaded environment is a situation where two or more threads are unable to
                    proceed because each is waiting for the other to release resources. Essentially, it’s a state where
                    threads are stuck indefinitely due to a circular dependency on resources, which results in a
                    complete halt of progress in the involved threads.</p>

                <h4>How Deadlock Occurs</h4>
                <p>Deadlock typically occurs when the following four conditions, known as the Coffman conditions, are
                    met:</p>
                <ul>
                    <li><strong>Mutual Exclusion:</strong> At least one resource must be held in a non-shareable mode.
                        Only one thread can use the resource at a time.
                    </li>
                    <li><strong>Hold and Wait:</strong> A thread holding at least one resource is waiting to acquire
                        additional resources held by other threads.
                    </li>
                    <li><strong>No Preemption:</strong> Resources cannot be forcibly taken away from threads holding
                        them. A thread must release the resource voluntarily.
                    </li>
                    <li><strong>Circular Wait:</strong> A set of threads are waiting for each other in a circular chain.
                        Each thread holds a resource that the next thread in the chain is waiting for.
                    </li>
                </ul>

                <h4>Example of Deadlock</h4>
                <div class="code">
                    <span class="keyword">class</span> <span class="class-name">Resource1</span> {
                    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span
                        class="method-name">method1</span>(<span class="class-name">Resource2</span> r2) {
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Thread1: Holding Resource1..."</span>);
                    <span class="keyword">try</span> { <span class="keyword">Thread</span>.<span class="method-name">sleep</span>(<span
                        class="number">100</span>); } <span class="keyword">catch</span> (<span class="class-name">InterruptedException</span>
                    e) {}
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Thread1: Waiting for Resource2..."</span>);
                    r2.<span class="method-name">last</span>();
                    }

                    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span
                        class="method-name">last</span>() {
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Thread1: Locked Resource1"</span>);
                    }
                    }

                    <span class="keyword">class</span> <span class="class-name">Resource2</span> {
                    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span
                        class="method-name">method2</span>(<span class="class-name">Resource1</span> r1) {
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Thread2: Holding Resource2..."</span>);
                    <span class="keyword">try</span> { <span class="keyword">Thread</span>.<span class="method-name">sleep</span>(<span
                        class="number">100</span>); } <span class="keyword">catch</span> (<span class="class-name">InterruptedException</span>
                    e) {}
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Thread2: Waiting for Resource1..."</span>);
                    r1.<span class="method-name">last</span>();
                    }

                    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span
                        class="method-name">last</span>() {
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Thread2: Locked Resource2"</span>);
                    }
                    }

                    <span class="keyword">public class</span> <span class="class-name">DeadlockExample</span> {
                    <span class="keyword">public static void</span> <span class="keyword">void</span> <span
                        class="method-name">main</span>(<span class="keyword">String</span>[] <span class="variable">args</span>)
                    {
                    <span class="keyword">final</span> <span class="class-name">Resource1</span> r1 = <span
                        class="keyword">new</span> <span class="class-name">Resource1</span>();
                    <span class="keyword">final</span> <span class="class-name">Resource2</span> r2 = <span
                        class="keyword">new</span> <span class="class-name">Resource2</span>();

                    <span class="keyword">Thread</span> t1 = <span class="keyword">new</span> <span class="keyword">Thread</span>(()
                    -> r1.<span class="method-name">method1</span>(r2));
                    <span class="keyword">Thread</span> t2 = <span class="keyword">new</span> <span class="keyword">Thread</span>(()
                    -> r2.<span class="method-name">method2</span>(r1));

                    t1.<span class="method-name">start</span>();
                    t2.<span class="method-name">start</span>();
                    }
                    }
                </div>

                <h4>Explanation:</h4>
                <ul>
                    <li>Thread t1 holds <span class="class-name">Resource1</span> and tries to acquire <span
                            class="class-name">Resource2</span>.
                    </li>
                    <li>Thread t2 holds <span class="class-name">Resource2</span> and tries to acquire <span
                            class="class-name">Resource1</span>.
                    </li>
                    <li>Both threads are waiting on each other, resulting in a deadlock.</li>
                </ul>

                <h4>How to Detect Deadlock</h4>
                <ul>
                    <li><strong>Thread Dump Analysis:</strong> Analyze thread dumps to identify threads waiting for
                        resources. Tools like <span class="class-name">VisualVM</span>, <span class="class-name">jConsole</span>,
                        or <span class="class-name">jstack</span> can help generate thread dumps.
                    </li>
                    <li><strong>Deadlock Detection Algorithms:</strong> Use algorithms like the <span
                            class="class-name">Banker's algorithm</span> to detect circular wait conditions in resource
                        allocation systems.
                    </li>
                    <li><strong>Logging and Monitoring:</strong> Implement logging to track resource acquisition and
                        release to detect patterns leading to deadlocks.
                    </li>
                </ul>

                <h4>How to Resolve Deadlock</h4>
                <ul>
                    <li><strong>Avoid Circular Wait:</strong>
                        <ul>
                            <li><strong>Resource Ordering:</strong> Define a global order for resource acquisition.
                                Ensure all threads acquire resources in the same order to prevent circular waits.
                            </li>
                            <li><strong>Lock Hierarchy:</strong> Implement a lock hierarchy where threads acquire locks
                                in a predefined order.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Use Timeout:</strong>
                        <ul>
                            <li><strong>Timeout Mechanisms:</strong> Use timeout mechanisms when acquiring locks. If a
                                thread cannot acquire a lock within a certain time, it backs off and retries.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Detect and Recover:</strong>
                        <ul>
                            <li><strong>Deadlock Detection:</strong> Implement deadlock detection algorithms to identify
                                deadlocks. Once detected, take corrective actions such as aborting one of the threads or
                                releasing resources.
                            </li>
                            <li><strong>Thread Interruption:</strong> Allow threads to be interrupted and handle
                                interruptions gracefully to avoid indefinite blocking.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Use Higher-Level Concurrency Utilities:</strong>
                        <ul>
                            <li><strong>Java Concurrency Utilities:</strong> Use higher-level concurrency utilities
                                provided by the <span class="class-name">java.util.concurrent</span> package, such as
                                <span class="class-name">ReentrantLock</span> with timeouts, <span class="class-name">Semaphore</span>,
                                or <span class="class-name">CountDownLatch</span>, which provide advanced locking
                                mechanisms and avoid deadlocks.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Minimize Lock Scope:</strong>
                        <ul>
                            <li><strong>Granular Locking:</strong> Reduce the scope of synchronized blocks to minimize
                                the duration of resource holding and reduce the chances of deadlock.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Lock-Free Data Structures:</strong>
                        <ul>
                            <li><strong>Lock-Free Alternatives:</strong> Consider using lock-free data structures and
                                algorithms, such as those provided in the <span
                                        class="class-name">java.util.concurrent</span> package, to avoid traditional
                                locking and reduce deadlock risks.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h4>Example of Avoiding Deadlock</h4>
                <div class="code">
                    <span class="keyword">class</span> <span class="class-name">Resource</span> {
                    <span class="keyword">private final</span> <span class="keyword">String</span> <span
                        class="variable">name</span>;

                    <span class="keyword">public</span> <span class="class-name">Resource</span>(<span class="keyword">String</span>
                    name) {
                    <span class="keyword">this</span>.<span class="variable">name</span> = name;
                    }

                    <span class="keyword">public</span> <span class="keyword">String</span> <span class="method-name">getName</span>()
                    {
                    <span class="keyword">return</span> <span class="variable">name</span>;
                    }

                    <span class="keyword">public synchronized void</span> <span class="method-name">use</span>(<span
                        class="class-name">Resource</span> other) {
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Thread " + <span class="keyword">Thread</span>.<span class="method-name">currentThread</span>().<span
                        class="method-name">getName</span>() + " using " + <span class="variable">name</span></span>);
                    other.<span class="method-name">doSomething</span>();
                    }

                    <span class="keyword">public synchronized void</span> <span class="method-name">doSomething</span>()
                    {
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Thread " + <span class="keyword">Thread</span>.<span class="method-name">currentThread</span>().<span
                        class="method-name">getName</span>() + " doing something with " + <span
                        class="variable">name</span></span>);
                    }
                    }

                    <span class="keyword">public class</span> <span class="class-name">DeadlockAvoidanceExample</span> {
                    <span class="keyword">public static void</span> <span class="keyword">void</span> <span
                        class="method-name">main</span>(<span class="keyword">String</span>[] <span class="variable">args</span>)
                    {
                    <span class="keyword">final</span> <span class="class-name">Resource</span> r1 = <span
                        class="keyword">new</span> <span class="class-name">Resource</span>(<span class="string">"Resource1"</span>);
                    <span class="keyword">final</span> <span class="class-name">Resource</span> r2 = <span
                        class="keyword">new</span> <span class="class-name">Resource</span>(<span class="string">"Resource2"</span>);

                    <span class="keyword">Thread</span> t1 = <span class="keyword">new</span> <span class="keyword">Thread</span>(()
                    -> {
                    <span class="keyword">if</span> (r1.<span class="method-name">getName</span>().<span
                        class="method-name">compareTo</span>(r2.<span class="method-name">getName</span>()) < <span
                        class="number">0</span>) {
                    r1.<span class="method-name">use</span>(r2);
                    } <span class="keyword">else</span> {
                    r2.<span class="method-name">use</span>(r1);
                    }
                    });

                    <span class="keyword">Thread</span> t2 = <span class="keyword">new</span> <span class="keyword">Thread</span>(()
                    -> {
                    <span class="keyword">if</span> (r1.<span class="method-name">getName</span>().<span
                        class="method-name">compareTo</span>(r2.<span class="method-name">getName</span>()) < <span
                        class="number">0</span>) {
                    r1.<span class="method-name">use</span>(r2);
                    } <span class="keyword">else</span> {
                    r2.<span class="method-name">use</span>(r1);
                    }
                    });

                    t1.<span class="method-name">start</span>();
                    t2.<span class="method-name">start</span>();
                    }
                    }
                </div>

                <h4>Explanation:</h4>
                <ul>
                    <li>The threads acquire locks based on the order determined by the names of the resources, thus
                        avoiding circular waits.
                    </li>
                </ul>

                <h3>12. What is a volatile Variable?</h3>
                <p>A variable declared with the <span class="keyword">volatile</span> keyword is known as a volatile
                    variable. It guarantees that:</p>
                <ul>
                    <li><strong>Visibility:</strong> Changes to the variable made by one thread are visible to all other
                        threads immediately. This means that if one thread updates the value of a volatile variable,
                        other threads will see the updated value without any delay.
                    </li>
                    <li><strong>Atomicity of Reads/Writes:</strong> The read and write operations on a volatile variable
                        are atomic. This means that reads and writes are completed in a single step, without
                        interference from other threads.
                    </li>
                </ul>

                <h3>13. Thread Priority</h3>
                <p>Thread Priority Levels:</p>
                <div class="code">
                    <span class="keyword">public static final int</span> <span class="variable">MIN_PRIORITY</span> =
                    <span class="number">1</span>;
                    <span class="keyword">public static final int</span> <span class="variable">NORM_PRIORITY</span> =
                    <span class="number">5</span>;<span class="comment"> // Default</span>
                    <span class="keyword">public static final int</span> <span class="variable">MAX_PRIORITY</span> =
                    <span class="number">10</span>;
                </div>
                <p>Setting Thread Priority:</p>
                <div class="code">
                    <span class="keyword">Thread</span> thread = <span class="keyword">new</span> <span class="keyword">Thread</span>(()
                    -> {
                    <span class="comment">// Thread task</span>
                    });
                    thread.<span class="method-name">setPriority</span>(<span class="class-name">Thread</span>.<span
                        class="variable">MAX_PRIORITY</span>); <span class="comment">// Set the highest priority</span>
                </div>
                <p>Getting Thread Priority:</p>
                <div class="code">
                    <span class="keyword">int</span> <span class="variable">priority</span> = thread.<span
                        class="method-name">getPriority</span>();
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Thread priority: " + <span class="variable">priority</span></span>);
                </div>

                <h3>14. Executor Framework</h3>
                <p>The Executor framework in Java is a powerful utility for managing threads, providing a higher-level
                    replacement for working directly with <span class="class-name">Thread</span> objects, it provides a
                    flexible and efficient way to create, submit, and manage threads. It allows developers to manage a
                    pool of worker threads, schedule tasks, and decouple task submission from task execution.</p>

                <h4>Key Points of the Executor Framework</h4>
                <ul>
                    <li><strong>Abstraction of Thread Management:</strong>
                        <ul>
                            <li>The Executor framework provides a simple way to decouple task submission from task
                                execution, handling all the thread management behind the scenes.
                            </li>
                            <li>It allows you to submit tasks without worrying about the details of thread creation,
                                lifecycle management, and other low-level threading concerns.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Thread Pooling:</strong>
                        <ul>
                            <li>The framework manages a pool of worker threads, reusing them to execute multiple
                                tasks.
                            </li>
                            <li>This reduces the overhead associated with thread creation and destruction, improving
                                performance, especially in applications that need to handle many tasks.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Task Submission Interfaces:</strong>
                        <ul>
                            <li><span class="class-name">Executor</span>: Basic interface for task submission.</li>
                            <li><span class="class-name">ExecutorService</span>: Extends <span class="class-name">Executor</span>,
                                providing lifecycle management and task scheduling capabilities.
                            </li>
                            <li><span class="class-name">ScheduledExecutorService</span>: Extends <span
                                    class="class-name">ExecutorService</span>, adding the ability to schedule tasks to
                                run after a delay or periodically.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Task Execution Policies:</strong>
                        <ul>
                            <li>The Executor framework allows you to define policies for how tasks should be executed,
                                such as fixed thread pool, cached thread pool, single-threaded executors, etc.
                            </li>
                            <li>This flexibility helps optimize the performance of your application based on specific
                                needs.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Future and Callable:</strong>
                        <ul>
                            <li><span class="class-name">Callable</span> is similar to <span
                                    class="class-name">Runnable</span> but can return a result and throw a checked
                                exception.
                            </li>
                            <li><span class="class-name">Future</span> represents the result of an asynchronous
                                computation, providing methods to check if the computation is complete, to wait for its
                                completion, and to retrieve the result.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h4>Example: Using ExecutorService</h4>
                <div class="code">
                    <span class="keyword">import</span> <span
                        class="class-name">java.util.concurrent.ExecutorService</span>;
                    <span class="keyword">import</span> <span class="class-name">java.util.concurrent.Executors</span>;

                    <span class="keyword">public class</span> <span class="class-name">ExecutorServiceExample</span> {
                    <span class="keyword">public static void</span> <span class="keyword">void</span> <span
                        class="method-name">main</span>(<span class="keyword">String</span>[] <span class="variable">args</span>)
                    {
                    <span class="keyword">ExecutorService</span> executor = <span
                        class="class-name">Executors</span>.<span class="method-name">newFixedThreadPool</span>(<span
                        class="number">3</span>);

                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;
                    i <= <span class="number">5</span>; i++) {
                    <span class="class-name">Runnable</span> worker = <span class="keyword">new</span> <span
                        class="class-name">WorkerThread</span>(<span class="string">"Task " + i</span>);
                    executor.<span class="method-name">execute</span>(worker);
                    }

                    executor.<span class="method-name">shutdown</span>();

                    <span class="keyword">while</span> (!executor.<span class="method-name">isTerminated</span>()) {
                    }

                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"All tasks are finished!"</span>);
                    }
                    }

                    <span class="keyword">class</span> <span class="class-name">WorkerThread</span> <span
                        class="keyword">implements</span> <span class="class-name">Runnable</span> {
                    <span class="keyword">private</span> <span class="keyword">String</span> <span class="variable">command</span>;

                    <span class="keyword">public</span> <span class="class-name">WorkerThread</span>(<span
                        class="keyword">String</span> command) {
                    <span class="keyword">this</span>.<span class="variable">command</span> = command;
                    }

                    @Override
                    <span class="keyword">public void</span> <span class="method-name">run</span>() {
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="keyword">Thread</span>.<span class="method-name">currentThread</span>().<span
                        class="method-name">getName</span>() + <span class="string">" Start. Command = "</span> + <span
                        class="variable">command</span>);
                    <span class="method-name">processCommand</span>();
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="keyword">Thread</span>.<span class="method-name">currentThread</span>().<span
                        class="method-name">getName</span>() + <span class="string">" End."</span>);
                    }

                    <span class="keyword">private void</span> <span class="method-name">processCommand</span>() {
                    <span class="keyword">try</span> {
                    <span class="keyword">Thread</span>.<span class="method-name">sleep</span>(<span
                        class="number">2000</span>);
                    } <span class="keyword">catch</span> (<span class="class-name">InterruptedException</span> e) {
                    e.<span class="method-name">printStackTrace</span>();
                    }
                    }
                    }
                </div>

                <h4>Explanation:</h4>
                <ul>
                    <li><strong>ExecutorService Creation:</strong>
                        <ul>
                            <li><span class="class-name">Executors.newFixedThreadPool(3)</span> creates a thread pool
                                with three threads.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Task Submission:</strong>
                        <ul>
                            <li>The <span class="method-name">execute</span> method is used to submit <span
                                    class="class-name">Runnable</span> tasks for execution.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Graceful Shutdown:</strong>
                        <ul>
                            <li><span class="method-name">executor.shutdown()</span> initiates a shutdown in which
                                previously submitted tasks are executed, but no new tasks will be accepted.
                            </li>
                            <li><span class="method-name">executor.isTerminated()</span> checks if all tasks have
                                completed following the shutdown request.
                            </li>
                        </ul>
                    </li>
                    <li><strong>WorkerThread Class:</strong>
                        <ul>
                            <li>Implements <span class="class-name">Runnable</span>, where the <span
                                    class="method-name">run()</span> method defines the task logic.
                            </li>
                            <li><span class="method-name">Thread.sleep(2000)</span> simulates a task taking 2 seconds to
                                complete.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h4>Example: Using Future and Callable</h4>
                <div class="code">
                    <span class="keyword">import</span> <span class="class-name">java.util.concurrent.Callable</span>;
                    <span class="keyword">import</span> <span
                        class="class-name">java.util.concurrent.ExecutorService</span>;
                    <span class="keyword">import</span> <span class="class-name">java.util.concurrent.Executors</span>;
                    <span class="keyword">import</span> <span class="class-name">java.util.concurrent.Future</span>;

                    <span class="keyword">public class</span> <span class="class-name">CallableFutureExample</span> {
                    <span class="keyword">public static void</span> <span class="keyword">void</span> <span
                        class="method-name">main</span>(<span class="keyword">String</span>[] <span class="variable">args</span>)
                    {
                    <span class="keyword">ExecutorService</span> executor = <span
                        class="class-name">Executors</span>.<span class="method-name">newFixedThreadPool</span>(<span
                        class="number">3</span>);

                    <span class="keyword">Future&lt;Integer&gt;</span> future = executor.<span class="method-name">submit</span>(<span
                        class="keyword">new</span> <span class="class-name">FactorialCalculator</span>(<span
                        class="number">5</span>));

                    <span class="keyword">try</span> {
                    <span class="keyword">Integer</span> result = future.<span class="method-name">get</span>();
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Factorial of 5 is: "</span> + result);
                    } <span class="keyword">catch</span> (<span class="class-name">Exception</span> e) {
                    e.<span class="method-name">printStackTrace</span>();
                    }

                    executor.<span class="method-name">shutdown</span>();
                    }
                    }

                    <span class="keyword">class</span> <span class="class-name">FactorialCalculator</span> <span
                        class="keyword">implements</span> <span class="class-name">Callable&lt;Integer&gt;</span> {
                    <span class="keyword">private</span> <span class="keyword">int</span> <span
                        class="variable">number</span>;

                    <span class="keyword">public</span> <span class="class-name">FactorialCalculator</span>(<span
                        class="keyword">int</span> number) {
                    <span class="keyword">this</span>.<span class="variable">number</span> = number;
                    }

                    @Override
                    <span class="keyword">public Integer</span> <span class="method-name">call</span>() {
                    <span class="keyword">int</span> <span class="variable">result</span> = <span
                        class="number">1</span>;
                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;
                    i <= <span class="variable">number</span>; i++) {
                    <span class="variable">result</span> *= i;
                    }
                    <span class="keyword">return</span> <span class="variable">result</span>;
                    }
                    }
                </div>

                <h4>Explanation:</h4>
                <ul>
                    <li><strong>Callable Interface:</strong> The <span class="class-name">Callable&lt;Integer&gt;</span>
                        interface is used to perform tasks that return a result and can throw exceptions.
                    </li>
                    <li><strong>Future Interface:</strong> The <span class="class-name">Future&lt;Integer&gt;</span>
                        interface provides methods to get the result of the computation, check if it is complete, and
                        handle exceptions.
                    </li>
                    <li><strong>Submitting Callable Tasks:</strong> The <span class="method-name">submit</span> method
                        of <span class="class-name">ExecutorService</span> is used to submit tasks that return results.
                    </li>
                    <li><strong>Getting Results:</strong> The <span class="method-name">get</span> method of <span
                            class="class-name">Future</span> is used to retrieve the result of the computation. It
                        blocks until the result is available.
                    </li>
                </ul>
                <h4>15. Future Interface</h4>
                <p>In Java multithreading, Future is an interface that represents the result of an asynchronous
                    computation. It provides methods to check if the computation is complete, to wait for its
                    completion, and to retrieve the result of the computation. If necessary, you can also cancel the
                    computation.</p>
                <h3>Key Concepts of Future</h3>
                <ul>
                    <li><strong>Asynchronous Computation:</strong>
                        <ul>
                            <li>Future allows you to work with tasks that are executed asynchronously. This means the
                                task might still be running or might have already completed when you try to retrieve its
                                result.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Task Submission:</strong>
                        <ul>
                            <li>When you submit a <span class="class-name">Callable</span> or <span class="class-name">Runnable</span>
                                task to an <span class="class-name">ExecutorService</span>, you receive a <span
                                        class="class-name">Future</span> object. This object acts as a handle to
                                interact with the ongoing task.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Methods of Future:</strong>
                        <ul>
                            <li><span class="method-name">get()</span>: Retrieves the result of the computation,
                                blocking if necessary until the computation is complete.
                            </li>
                            <li><span class="method-name">isDone()</span>: Checks if the computation has completed.</li>
                            <li><span class="method-name">isCancelled()</span>: Checks if the computation was canceled
                                before it completed normally.
                            </li>
                            <li><span class="method-name">cancel(boolean mayInterruptIfRunning)</span>: Attempts to
                                cancel the execution of the task.
                            </li>
                            <li><span class="method-name">get(long timeout, TimeUnit unit)</span>: Retrieves the result,
                                waiting at most the given time for the computation to complete.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Cancellation:</strong>
                        <ul>
                            <li>You can cancel a task using the <span class="method-name">cancel()</span> method. If the
                                task has already completed, it cannot be canceled. If it is still running, whether it
                                can be interrupted depends on the argument passed to <span
                                        class="method-name">cancel()</span>.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Blocking and Non-Blocking Calls:</strong>
                        <ul>
                            <li>The <span class="method-name">get()</span> method is blocking; it waits for the task to
                                complete if it hasn't already.
                            </li>
                            <li>The <span class="method-name">isDone()</span> method is non-blocking; it simply checks
                                the status of the task.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h3>Example: Using Future with Callable</h3>
                <div class="code">
                    <span class="keyword">import</span> <span class="class-name">java.util.concurrent.Callable</span>;
                    <span class="keyword">import</span> <span
                        class="class-name">java.util.concurrent.ExecutorService</span>;
                    <span class="keyword">import</span> <span class="class-name">java.util.concurrent.Executors</span>;
                    <span class="keyword">import</span> <span class="class-name">java.util.concurrent.Future</span>;

                    <span class="keyword">public class</span> <span class="class-name">FutureExample</span> {
                    <span class="keyword">public static void</span> <span class="keyword">void</span> <span
                        class="method-name">main</span>(<span class="keyword">String</span>[] <span class="variable">args</span>)
                    {
                    <span class="comment">// Create a thread pool with 2 threads</span>
                    <span class="class-name">ExecutorService</span> <span class="variable">executor</span> = <span
                        class="class-name">Executors</span>.<span class="method-name">newFixedThreadPool</span>(<span
                        class="number">2</span>);

                    <span class="comment">// Submit a Callable task</span>
                    <span class="class-name">Future&lt;Integer&gt;</span> <span class="variable">future</span> = <span
                        class="variable">executor</span>.<span class="method-name">submit</span>(<span class="keyword">new</span>
                    <span class="class-name">FactorialCalculator</span>(<span class="number">5</span>));

                    <span class="comment">// Perform some other operations while the task is running</span>
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Doing other tasks..."</span>);

                    <span class="keyword">try</span> {
                    <span class="comment">// Wait for the result from the future</span>
                    <span class="keyword">Integer</span> <span class="variable">result</span> = <span class="variable">future</span>.<span
                        class="method-name">get</span>(); <span class="comment">// This call will block until the result is available</span>
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Factorial of 5 is: "</span> + <span class="variable">result</span>);
                    } <span class="keyword">catch</span> (<span class="class-name">Exception</span> <span
                        class="variable">e</span>) {
                    <span class="variable">e</span>.<span class="method-name">printStackTrace</span>();
                    }

                    <span class="comment">// Shutdown the executor</span>
                    <span class="variable">executor</span>.<span class="method-name">shutdown</span>();
                    }
                    }

                    <span class="keyword">class</span> <span class="class-name">FactorialCalculator</span> <span
                        class="keyword">implements</span> <span class="class-name">Callable&lt;Integer&gt;</span> {
                    <span class="keyword">private final</span> <span class="keyword">int</span> <span class="variable">number</span>;

                    <span class="keyword">public</span> <span class="class-name">FactorialCalculator</span>(<span
                        class="keyword">int</span> <span class="variable">number</span>) {
                    <span class="keyword">this</span>.<span class="variable">number</span> = <span class="variable">number</span>;
                    }

                    @Override
                    <span class="keyword">public Integer</span> <span class="method-name">call</span>() <span
                        class="keyword">throws</span> <span class="class-name">Exception</span> {
                    <span class="keyword">int</span> <span class="variable">result</span> = <span
                        class="number">1</span>;
                    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="variable">i</span> =
                    <span class="number">2</span>; <span class="variable">i</span> <= <span
                        class="variable">number</span>; <span class="variable">i</span>++) {
                    <span class="variable">result</span> *= <span class="variable">i</span>;
                    }
                    <span class="keyword">Thread</span>.<span class="method-name">sleep</span>(<span
                        class="number">2000</span>); <span class="comment">// Simulate a long-running task</span>
                    <span class="keyword">return</span> <span class="variable">result</span>;
                    }
                    }
                </div>

                <h3>Explanation:</h3>
                <ul>
                    <li><strong>Task Submission:</strong>
                        <ul>
                            <li>The <span class="class-name">FactorialCalculator</span> task is submitted to the <span
                                    class="class-name">ExecutorService</span> using the <span class="method-name">submit()</span>
                                method, which returns a <span class="class-name">Future&lt;Integer&gt;</span>.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Future Interaction:</strong>
                        <ul>
                            <li>The <span class="variable">future.get()</span> method is called to retrieve the result.
                                This method blocks until the computation is complete.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Other Operations:</strong>
                        <ul>
                            <li>While the task is running, other operations can be performed concurrently. The call to
                                <span class="method-name">get()</span> only blocks when you need the result.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Result Retrieval:</strong>
                        <ul>
                            <li>Once the computation is done, the result (factorial of 5) is printed.</li>
                        </ul>
                    </li>
                </ul>

                <h3>Example: Cancelling a Task with Future</h3>
                <div class="code">
                    <span class="keyword">import</span> <span class="class-name">java.util.concurrent.Callable</span>;
                    <span class="keyword">import</span> <span
                        class="class-name">java.util.concurrent.ExecutorService</span>;
                    <span class="keyword">import</span> <span class="class-name">java.util.concurrent.Executors</span>;
                    <span class="keyword">import</span> <span class="class-name">java.util.concurrent.Future</span>;

                    <span class="keyword">public class</span> <span class="class-name">FutureCancelExample</span> {
                    <span class="keyword">public static void</span> <span class="keyword">void</span> <span
                        class="method-name">main</span>(<span class="keyword">String</span>[] <span class="variable">args</span>)
                    {
                    <span class="comment">// Create a thread pool with 2 threads</span>
                    <span class="class-name">ExecutorService</span> <span class="variable">executor</span> = <span
                        class="class-name">Executors</span>.<span class="method-name">newFixedThreadPool</span>(<span
                        class="number">2</span>);

                    <span class="comment">// Submit a long-running Callable task</span>
                    <span class="class-name">Future&lt;Long&gt;</span> <span class="variable">future</span> = <span
                        class="variable">executor</span>.<span class="method-name">submit</span>(<span class="keyword">new</span>
                    <span class="class-name">LongRunningTask</span>());

                    <span class="keyword">try</span> {
                    <span class="comment">// Wait for the result for 1 second only</span>
                    <span class="keyword">Long</span> <span class="variable">result</span> = <span class="variable">future</span>.<span
                        class="method-name">get</span>(<span class="number">1</span>, <span class="class-name">java.util.concurrent.TimeUnit</span>.<span
                        class="method-name">SECONDS</span>);
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Result: "</span> + <span class="variable">result</span>);
                    } <span class="keyword">catch</span> (<span class="class-name">Exception</span> <span
                        class="variable">e</span>) {
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Task did not complete in time, attempting to cancel..."</span>);
                    <span class="variable">future</span>.<span class="method-name">cancel</span>(<span class="keyword">true</span>);
                    <span class="comment">// Attempt to cancel the task</span>
                    }

                    <span class="comment">// Check if the task was cancelled</span>
                    <span class="keyword">if</span> (<span class="variable">future</span>.<span class="method-name">isCancelled</span>())
                    {
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Task was cancelled."</span>);
                    } <span class="keyword">else</span> {
                    <span class="keyword">System</span>.<span class="method-name">out</span>.<span class="method-name">println</span>(<span
                        class="string">"Task completed successfully."</span>);
                    }

                    <span class="comment">// Shutdown the executor</span>
                    <span class="variable">executor</span>.<span class="method-name">shutdown</span>();
                    }
                    }

                    <span class="keyword">class</span> <span class="class-name">LongRunningTask</span> <span
                        class="keyword">implements</span> <span class="class-name">Callable&lt;Long&gt;</span> {
                    @Override
                    <span class="keyword">public Long</span> <span class="method-name">call</span>() <span
                        class="keyword">throws</span> <span class="class-name">Exception</span> {
                    <span class="comment">// Simulate a long-running task</span>
                    <span class="keyword">Thread</span>.<span class="method-name">sleep</span>(<span
                        class="number">5000</span>);
                    <span class="keyword">return</span> <span class="keyword">System</span>.<span class="method-name">currentTimeMillis</span>();
                    }
                    }
                </div>

                <h3>Explanation:</h3>
                <ul>
                    <li><strong>Timeout with get():</strong>
                        <ul>
                            <li>The <span class="variable">future.get(1, TimeUnit.SECONDS)</span> method is used to wait
                                for the result for only 1 second. If the task does not complete within this time, it
                                throws a <span class="class-name">TimeoutException</span>.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Cancellation:</strong>
                        <ul>
                            <li>When the task takes too long, <span class="variable">future.cancel(true)</span> is
                                called to cancel the task. The <span class="keyword">true</span> argument indicates that
                                the thread running the task should be interrupted.
                            </li>
                        </ul>
                    </li>
                    <li><strong>Check Cancellation:</strong>
                        <ul>
                            <li>The <span class="method-name">isCancelled()</span> method checks if the task was
                                successfully canceled. If so, a message is printed.
                            </li>
                        </ul>
                    </li>
                </ul>

                <h3>Use Cases for Future</h3>
                <ul>
                    <li><strong>Parallel Processing:</strong> When you need to perform multiple computations in parallel
                        and later combine the results.
                    </li>
                    <li><strong>Asynchronous Programming:</strong> When tasks can be executed in the background, and the
                        main thread continues with other work until the result is needed.
                    </li>
                    <li><strong>Timeout Control:</strong> When you need to ensure that tasks complete within a certain
                        time frame, and otherwise want to cancel them.
                    </li>
                </ul>

                <h3>Best Practices</h3>
                <ul>
                    <li><strong>Avoid Blocking Calls:</strong> Use <span class="method-name">Future.get()</span>
                        carefully, as it can block the calling thread. Consider using timeouts with <span
                                class="method-name">get(long timeout, TimeUnit unit)</span>.
                    </li>
                    <li><strong>Handle Cancellations:</strong> Ensure that your tasks handle interruptions properly,
                        especially when using <span class="method-name">cancel(true)</span>.
                    </li>
                    <li><strong>Use Proper Exception Handling:</strong> <span class="class-name">Callable</span> tasks
                        can throw checked exceptions, so you should handle these exceptions when using <span
                                class="method-name">Future.get()</span>.
                    </li>
                </ul>

                <p>The <span class="class-name">Future</span> interface is a core part of Java’s concurrency utilities,
                    offering a robust way to manage and interact with asynchronous tasks.</p>
                <h1><a name="miscellaneous">9. Java Miscellaneous Interview Questions</a></h1>
                <h4>1. What is Exchanger class?</h4>
                <p>The <span class="class-name">Exchanger</span> class in Java is a synchronization point at which
                    threads can pair and swap elements within pairs. Each thread presents some object on exchange and
                    receives another object in return from another thread.</p>

                <h4>2. What is reflection in Java?</h4>
                <p>Reflection in Java is a capability to inspect and modify the runtime behavior of applications. It
                    allows programs to manipulate internal properties of <span class="class-name">classes</span>, <span
                            class="class-name">methods</span>, <span class="class-name">interfaces</span>, and
                    dynamically call them at runtime.</p>

                <h4>3. What is the weak reference and soft reference in Java?</h4>
                <p><span class="class-name">Weak references</span> in Java are garbage collected when no strong
                    references exist. <span class="class-name">Soft references</span> are only cleared at the discretion
                    of the garbage collector, typically when memory is low.</p>

                <h4>4. What is Java Flight Recorder?</h4>
                <p><span class="class-name">Java Flight Recorder</span> (<span class="class-name">JFR</span>) is a tool
                    for collecting diagnostic and profiling data about a running Java application without significant
                    performance overhead.</p>

                <h4>5. Can we create a server in Java application without creating Spring or any other framework?</h4>
                <p>Yes, you can create a server in a Java application using only Java SE APIs, such as by utilizing the
                    <span class="class-name">ServerSocket</span> class for a simple TCP server or the <span
                            class="class-name">HttpServer</span> class for HTTP services.</p>

                <h4>6. Name of algorithm used by Arrays.sort(..) and Collections.sort(..)?</h4>
                <p><span class="class-name">Arrays.sort()</span> uses a <span
                        class="keyword">Dual-Pivot Quicksort</span> algorithm for primitive types and <span
                        class="keyword">TimSort</span> for object arrays. <span
                        class="class-name">Collections.sort()</span> uses <span class="keyword">TimSort</span>, a hybrid
                    sorting algorithm combining merge sort and insertion sort.</p>

                <h4>7. Can you tell me some new features that were introduced in Java 11?</h4>
                <p><span class="keyword">HTTP Client</span>, <span class="keyword">Epsilon Garbage Collector</span>,
                    <span class="keyword">Z Garbage Collector</span>, <span class="keyword">Local-Variable Syntax for Lambda Parameters</span>
                    are some of the new features and along with these new features, <span
                            class="method-name">isBlank()</span>, <span class="method-name">strip()</span>, <span
                            class="method-name">stripLeading()</span>, <span class="method-name">stripTrailing()</span>,
                    and <span class="method-name">repeat()</span> were also introduced for strings.</p>

                <h4>8. Can you tell me some new features that were introduced in Java 17?</h4>
                <p><span class="keyword">Sealed Classes</span>, <span class="keyword">Pattern Matching for switch</span>,
                    <span class="keyword">Foreign Function and Memory API</span> are some of the examples.</p>

                <h4>9. Can you tell me some new features that were introduced in Java 21?</h4>
                <p><span class="keyword">Virtual Threads</span>, <span class="keyword">Structured Concurrency</span>,
                    <span class="keyword">Sco</span>.</p>

                <h4>10. What is the static keyword in Java?</h4>
                <p>The <span class="keyword">static</span> keyword in Java is used to indicate that a particular member
                    (<span class="variable">variable</span> or <span class="method-name">method</span>) belongs to the
                    class, rather than any instance of the class. This means that the static member can be accessed
                    without creating an instance of the class.</p>

                <h4>11. Can a static block throw an exception?</h4>
                <p>Yes, a static block can throw an exception, but if it does, the exception must be handled within the
                    block itself or declared using a <span class="keyword">throws</span> clause in the class.</p>

                <h4>12. Can we override static methods in Java?</h4>
                <p>No, static methods cannot be overridden in Java because method overriding is based on dynamic binding
                    at runtime and static methods are bound at compile time.</p>

                <h4>13. Is it possible to access non-static members from within a static method?</h4>
                <p>Yes, it's possible to access non-static members from within a static method by creating an instance
                    of the class containing those members.</p>

                <h4>14. What is static block?</h4>
                <p>To initialize static variables, the statements inside <span class="variable">static block</span> are
                    executed only once, when the class is loaded into memory.</p>

                <h4>15. Can we print something on console without main method in Java?</h4>
                <p>Prior to Java 8, yes, we could print something without <span class="variable">main</span> method but
                    it's not possible from Java 8 onwards.</p>

                <h4>16. What is 'this' and 'super' keyword in Java?</h4>
                <p><span class="variable">'this'</span> is used to refer to the current class's instance as well as
                    static members. <span class="variable">'super'</span> keyword is used to access methods of the
                    parent class.</p>

                <h4>17. Can 'this' keyword be assigned a new value in Java?</h4>
                <p>No, <span class="variable">'this'</span> keyword cannot be assigned a new value in Java. It is a
                    read-only reference that always points to the current object.</p>

                <h4>18. What happens if you attempt to use the "super" keyword in a class that doesn't have a
                    superclass?</h4>
                <p>If we attempt to use the <span class="variable">"super"</span> keyword in a class that doesn't have a
                    superclass, a compilation error occurs. The <span class="variable">"super"</span> keyword is only
                    applicable within subclasses to refer to members of the superclass.</p>

                <h4>19. Can the this or super keyword be used in a static method?</h4>
                <p>No, the <span class="variable">this</span> and <span class="variable">super</span> keyword cannot be
                    used in static methods. Static methods belong to the class, not instances, and <span
                            class="variable">super</span> refers to the superclass's object context, which does not
                    exist in a static context.</p>

                <h4>20. How does 'super' play a role in polymorphism?</h4>
                <p>In Java, the <span class="variable">super</span> keyword lets a subclass use methods from its parent
                    class, helping it behave in different ways and that is nothing but a polymorphic behaviour.</p>

                <h4>21. What are the ways to create an object?</h4>
                <ul>
                    <li>Using the <span class="keyword">new</span> Keyword, example: <span class="variable">MyClass object = new MyClass();</span>
                    </li>
                    <li>Using <span class="class-name">Class Factory Methods</span>, example: <span class="variable">Calendar calendar = Calendar.getInstance();</span>
                    </li>
                    <li>Using the <span class="method-name">clone()</span></li>
                </ul>

                <h4>22. Can a top-level class be private or protected in Java?</h4>
                <p>No, a top-level class cannot be private or protected because it restricts access, making it unusable
                    from any other classes, contrary to the purpose of a top-level class.</p>

                <h4>23. Can you provide examples of when to use each type of access modifier?</h4>
                <ul>
                    <li><span class="keyword">Public</span>: Used when members should be accessible from any other
                        class.
                    </li>
                    <li><span class="keyword">Protected</span>: Ideal for members that should be accessible to
                        subclasses and classes within the same package.
                    </li>
                    <li><span class="keyword">Default</span>: Use when members should be accessible only within the same
                        package.
                    </li>
                    <li><span class="keyword">Private</span>: Best for members intended only for use within their own
                        class.
                    </li>
                </ul>

                <h4>24. Can you explain the difference between unboxing and autoboxing in Java?</h4>
                <p><span class="keyword">Autoboxing</span> automatically converts a primitive type (like <span
                        class="variable">int</span>) to its corresponding wrapper class (<span class="class-name">Integer</span>).
                    <span class="keyword">Unboxing</span> does the reverse, converting an <span class="class-name">Integer</span>
                    back to an <span class="variable">int</span>.</p>

                <h4>25. Can you provide an example where autoboxing could lead to unexpected behavior?</h4>
                <p>When comparing two <span class="class-name">Integer</span> instances using <span
                        class="keyword">==</span>, autoboxing might lead to false results because it compares object
                    references, not values, for integers outside the cache range of -128 to 127.</p>

                <h4>26. Is there a scenario where autoboxing and unboxing could cause a NullPointerException?</h4>
                <p>A <span class="class-name">NullPointerException</span> can occur if you unbox a null object; for
                    example, assigning <span class="variable">null</span> to an <span class="class-name">Integer</span>
                    and then using it in a context where an <span class="variable">int</span> is expected.</p>

                <h4>27. What are wrapper classes?</h4>
                <p>In Java, a <span class="class-name">wrapper class</span> is an object that encapsulates a primitive
                    data type. It allows primitives to be treated as objects. Each primitive data type has a
                    corresponding wrapper class (e.g., <span class="class-name">Integer</span> for <span
                            class="variable">int</span>, <span class="class-name">Double</span> for <span
                            class="variable">double</span>).</p>

                <h4>28. Why do we need wrapper classes?</h4>
                <ul>
                    <li>Wrapper classes are final and immutable.</li>
                    <li>Provides methods like <span class="method-name">valueOf()</span>, <span class="method-name">parseInt()</span>,
                        etc.
                    </li>
                    <li>It provides the feature of autoboxing and unboxing.</li>
                </ul>

                <h4>29. Why do we use wrapper class in collections?</h4>
                <p>Because Java collections, such as <span class="class-name">ArrayList</span>, <span
                        class="class-name">HashMap</span>, and others in the Java Collections Framework, can only hold
                    objects and not primitive types. Wrapper classes allow primitive values to be treated as objects,
                    enabling them to be stored and managed within these collections.</p>

                <h4>30. How can memory leaks occur in Java even with automatic garbage collection?</h4>
                <p>Memory leaks in Java occur when objects are no longer needed but still referenced from other
                    reachable objects, and hence preventing the garbage collector from reclaiming their memory.</p>

                <h4>31. Explain public static void main(String[] args)?</h4>
                <p>In Java, <span class="keyword">public static void main(String[] args)</span> is the entry point of
                    any standalone Java application. <span class="keyword">public</span> makes this method accessible
                    from anywhere, <span class="keyword">static</span> means I don't need to create an object to call
                    this method, <span class="keyword">void</span> means it doesn't return any value, and <span
                            class="variable">main</span> is the name of this method. The <span class="class-name">String[]</span>
                    <span class="variable">args</span> part is an array that holds any command-line arguments passed to
                    the program. So, when I run a Java program, this is the first method that gets called.</p>

                <h4>32. What will happen if we don't declare the main as static?</h4>
                <p>If I don't declare the main method as <span class="keyword">static</span> in a Java program, the JVM
                    won't be able to launch the application. As a result, the program will compile, but it will fail to
                    run, giving an error like "Main method is not static in class <span class="variable">myClass</span>,
                    please define the main method as: <span
                            class="keyword">public static void main(String[] args)</span>".</p>

                <h4>33. Can we override the main method?</h4>
                <p>No, we cannot override <span class="variable">main</span> method of Java because a <span
                        class="keyword">static</span> method cannot be overridden. The <span
                        class="keyword">static</span> method in Java is associated with the class whereas the non-static
                    method is associated with an object. <span class="keyword">Static</span> belongs to the class area,
                    static methods don’t need an object to be called.</p>

                <h4>34. Can we overload the main method?</h4>
                <p>Yes, we can overload the <span class="variable">main</span> method in Java by just changing its
                    argument. Can JVM execute our overloaded main method? No, JVM only calls the original <span
                            class="variable">main</span> method, it will never call our overloaded <span
                            class="variable">main</span> method.</p>

                <h4>35. What is Singleton Class?</h4>
                <p>A <span class="keyword">Singleton</span> class in Java is a design pattern that ensures only one
                    instance of the class is created throughout the application's lifetime. This is useful when exactly
                    one object is needed to coordinate actions across the system. The <span
                            class="keyword">Singleton</span> pattern provides a way to control access to this single
                    instance, ensuring that it is created only once and providing a global point of access to it.</p>

                <h4>36. Ways to Create a Singleton Class</h4>
                <p>Here are several common ways to implement a Singleton pattern in Java:</p>

                <h3>1. Eager Initialization</h3>
                <p>In eager initialization, the instance of the Singleton class is created at the time of class loading.
                    This ensures that the instance is available when needed but can cause a delay in application startup
                    time.</p>
                <div class="code">
                    <span class="keyword">public</span> <span class="keyword">class</span> <span class="class-name">EagerSingleton</span>
                    {
                    <span class="comment">// Create the single instance at the time of class loading</span>
                    <span class="keyword">private static final</span> <span class="class-name">EagerSingleton</span>
                    <span class="variable">instance</span> = <span class="keyword">new</span> <span class="class-name">EagerSingleton</span>();

                    <span class="comment">// Private constructor to prevent instantiation</span>
                    <span class="keyword">private</span> <span class="class-name">EagerSingleton</span>() {}

                    <span class="comment">// Public method to provide access to the instance</span>
                    <span class="keyword">public static</span> <span class="class-name">EagerSingleton</span> <span
                        class="method-name">getInstance</span>() {
                    <span class="keyword">return</span> <span class="variable">instance</span>;
                    }
                    }
                </div>
                <p><strong>Key Points:</strong></p>
                <ul>
                    <li>Instance is created at class loading time.</li>
                    <li>Thread-safe without synchronization overhead.</li>
                    <li>Might lead to resource wastage if the instance is not used.</li>
                </ul>

                <h3>2. Lazy Initialization</h3>
                <p>Lazy initialization creates the Singleton instance only when it is first needed. This approach is
                    more efficient in terms of resource usage, as the instance is created on demand.</p>
                <div class="code">
                    <span class="keyword">public</span> <span class="keyword">class</span> <span class="class-name">LazySingleton</span>
                    {
                    <span class="comment">// Declare the instance as volatile to ensure visibility</span>
                    <span class="keyword">private static volatile</span> <span class="class-name">LazySingleton</span>
                    <span class="variable">instance</span>;

                    <span class="comment">// Private constructor to prevent instantiation</span>
                    <span class="keyword">private</span> <span class="class-name">LazySingleton</span>() {}

                    <span class="comment">// Method to provide access to the instance</span>
                    <span class="keyword">public static</span> <span class="class-name">LazySingleton</span> <span
                        class="method-name">getInstance</span>() {
                    <span class="keyword">if</span> (<span class="variable">instance</span> == <span class="variable">null</span>)
                    {
                    <span class="keyword">synchronized</span> (<span class="class-name">LazySingleton</span>.class) {
                    <span class="keyword">if</span> (<span class="variable">instance</span> == <span class="variable">null</span>)
                    {
                    <span class="variable">instance</span> = <span class="keyword">new</span> <span class="class-name">LazySingleton</span>();
                    }
                    }
                    }
                    <span class="keyword">return</span> <span class="variable">instance</span>;
                    }
                    }
                </div>
                <p><strong>Key Points:</strong></p>
                <ul>
                    <li>Instance is created only when <span class="method-name">getInstance</span> is called.</li>
                    <li>Uses double-checked locking for thread safety.</li>
                    <li>More resource-efficient but involves synchronization overhead.</li>
                </ul>

                <h3>3. Bill Pugh Singleton Design</h3>
                <p>The Bill Pugh Singleton Design leverages the class loading mechanism to ensure thread-safe
                    initialization. It uses a static inner helper class to hold the Singleton instance.</p>
                <div class="code">
                    <span class="keyword">public</span> <span class="keyword">class</span> <span class="class-name">BillPughSingleton</span>
                    {
                    <span class="comment">// Static inner class responsible for holding the Singleton instance</span>
                    <span class="keyword">private static class</span> <span class="class-name">SingletonHelper</span> {
                    <span class="keyword">private static final</span> <span class="class-name">BillPughSingleton</span>
                    <span class="variable">INSTANCE</span> = <span class="keyword">new</span> <span class="class-name">BillPughSingleton</span>();
                    }

                    <span class="comment">// Private constructor to prevent instantiation</span>
                    <span class="keyword">private</span> <span class="class-name">BillPughSingleton</span>() {}

                    <span class="comment">// Public method to provide access to the instance</span>
                    <span class="keyword">public static</span> <span class="class-name">BillPughSingleton</span> <span
                        class="method-name">getInstance</span>() {
                    <span class="keyword">return</span> <span class="class-name">SingletonHelper</span>.<span
                        class="variable">INSTANCE</span>;
                    }
                    }
                </div>
                <p><strong>Key Points:</strong></p>
                <ul>
                    <li>Instance is created when <span class="method-name">getInstance</span> is called for the first
                        time.
                    </li>
                    <li>Utilizes the class loader mechanism for thread safety.</li>
                    <li>Efficient and avoids synchronization overhead.</li>
                </ul>

                <h3>4. Enum Singleton</h3>
                <p>Java's enum type provides a straightforward and effective way to implement a Singleton pattern. It
                    ensures that only one instance is created, and it is inherently thread-safe and prevents
                    serialization issues.</p>
                <div class="code">
                    <span class="keyword">public enum</span> <span class="class-name">SingletonEnum</span> {
                    <span class="variable">INSTANCE</span>;

                    <span class="keyword">public void</span> <span class="method-name">doSomething</span>() {
                    <span class="comment">// Method implementation here</span>
                    }
                    }
                </div>
                <p><strong>Key Points:</strong></p>
                <ul>
                    <li>Simple and effective way to implement Singleton.</li>
                    <li>Serialization and reflection issues are inherently handled.</li>
                    <li>Only one instance is guaranteed.</li>
                </ul>
        </div>
        </article>
</div>
<div class="card-footer">
    <ul class="pagination justify-content-center mb-4">
        <li class="page-item"><a class="page-link" href="../java/java-interview-questions.html">Next
            &rArr;</a></li>
    </ul>
</div>
<button onclick="topFunction()" id="myBtn" title="Go to top"><img height="30" width="30"
                                                                  src="../../scripts/images/top.jpeg"/></button>
</main>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.scrollTo(0, 0);
    })
</script>
<script>
    // Get the button
    let mybutton = document.getElementById("myBtn");

    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function () {scrollFunction()};

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            mybutton.style.display = "block";
        } else {
            mybutton.style.display = "none";
        }
    }
    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
</script>
<script src="../../scripts/js/site.js"></script>
</body>
<footer class="footer">
    <p>©
        <script>var d = new Date();
			document.write(d.getFullYear());
        </script>
        , The content is copyrighted to Ravi
        Kalyan Kolloju.
    </p>
</footer>

</html>